#!/bin/bash
# SwarmSH v2 - Worktree Management Shell Export
# Generated by SwarmSH v2 Tera templating system
# Coordination Patterns: {{ coordination_patterns | join(", ") }}
# Zero-Conflict Guarantee: Mathematical precision with nanosecond timestamps

set -euo pipefail

# Global configuration
SWARMSH_BASE_PATH="${SWARMSH_BASE_PATH:-$(pwd)/worktrees}"
SWARMSH_COORDINATION_DIR="${SWARMSH_COORDINATION_DIR:-/tmp/swarmsh-coordination}"
SWARMSH_AGENT_ID="${SWARMSH_AGENT_ID:-$(hostname)_$$_$(date +%s%N)}"
SWARMSH_TELEMETRY_FILE="${SWARMSH_COORDINATION_DIR}/worktree_telemetry.jsonl"

# Ensure coordination directory exists
mkdir -p "$SWARMSH_COORDINATION_DIR"

# Utility functions
generate_coordination_epoch() {
    echo "$(date +%s%N)"
}

generate_trace_id() {
    if command -v openssl >/dev/null 2>&1; then
        echo "$(openssl rand -hex 16)"
    else
        echo "$(cat /dev/urandom | tr -dc 'a-f0-9' | fold -w 32 | head -n 1)"
    fi
}

# OTEL-compatible telemetry logging
log_worktree_telemetry() {
    local operation_type="$1"
    local worktree_name="${2:-unknown}"
    local status="${3:-in_progress}"
    local coordination_epoch=$(generate_coordination_epoch)
    local trace_id=$(generate_trace_id)
    
    local telemetry_entry=$(cat << EOF
{
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
    "trace_id": "$trace_id",
    "span_id": "$(openssl rand -hex 8 2>/dev/null || echo $(date +%s%N | tail -c 16))",
    "swarmsh.worktree.operation": "$operation_type",
    "swarmsh.worktree.name": "$worktree_name",
    "swarmsh.worktree.status": "$status",
    "swarmsh.worktree.coordination_epoch": $coordination_epoch,
    "swarmsh.agent.id": "$SWARMSH_AGENT_ID",
    "swarmsh.worktree.coordination_pattern": "atomic"
}
EOF
)
    
    echo "$telemetry_entry" >> "$SWARMSH_TELEMETRY_FILE"
}

# Atomic file operations with advisory locking
atomic_worktree_operation() {
    local operation="$1"
    local worktree_name="$2"
    local lock_file="$SWARMSH_COORDINATION_DIR/worktree_${worktree_name}.lock"
    
    # Use file descriptor 200 for locking
    (
        flock -x 200
        local coordination_epoch=$(generate_coordination_epoch)
        log_worktree_telemetry "$operation" "$worktree_name" "executing"
        
        case "$operation" in
            "create")
                create_worktree_atomic "$worktree_name" "${3:-$worktree_name}"
                ;;
            "remove")
                remove_worktree_atomic "$worktree_name" "${3:-false}"
                ;;
            "sync")
                sync_worktree_atomic "$worktree_name"
                ;;
            "backup")
                backup_worktree_atomic "$worktree_name"
                ;;
            "restore")
                restore_worktree_atomic "$worktree_name" "${3:-latest}"
                ;;
            *)
                echo "Unknown operation: $operation" >&2
                return 1
                ;;
        esac
        
        log_worktree_telemetry "$operation" "$worktree_name" "completed"
    ) 200>"$lock_file"
}

# Core worktree operations
create_worktree_atomic() {
    local worktree_name="$1"
    local branch_name="${2:-$worktree_name}"
    local worktree_path="$SWARMSH_BASE_PATH/$worktree_name"
    
    echo "Creating worktree '$worktree_name' on branch '$branch_name'"
    
    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        echo "Error: Worktree '$worktree_name' already exists at '$worktree_path'" >&2
        log_worktree_telemetry "create" "$worktree_name" "failed"
        return 1
    fi
    
    # Create the worktree
    if git worktree add "$worktree_path" "$branch_name" 2>/dev/null; then
        echo "Worktree '$worktree_name' created successfully at '$worktree_path'"
        
        # Initialize worktree metadata
        create_worktree_metadata "$worktree_name" "$branch_name" "$worktree_path"
        return 0
    else
        echo "Error: Failed to create worktree '$worktree_name'" >&2
        log_worktree_telemetry "create" "$worktree_name" "failed"
        return 1
    fi
}

remove_worktree_atomic() {
    local worktree_name="$1"
    local force="${2:-false}"
    local worktree_path="$SWARMSH_BASE_PATH/$worktree_name"
    
    echo "Removing worktree '$worktree_name'"
    
    # Check if worktree exists
    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree '$worktree_name' not found at '$worktree_path'" >&2
        log_worktree_telemetry "remove" "$worktree_name" "failed"
        return 1
    fi
    
    # Remove the worktree
    local git_args=("worktree" "remove" "$worktree_path")
    if [[ "$force" == "true" ]]; then
        git_args+=("--force")
    fi
    
    if git "${git_args[@]}" 2>/dev/null; then
        echo "Worktree '$worktree_name' removed successfully"
        
        # Clean up metadata
        remove_worktree_metadata "$worktree_name"
        return 0
    else
        echo "Error: Failed to remove worktree '$worktree_name'" >&2
        log_worktree_telemetry "remove" "$worktree_name" "failed"
        return 1
    fi
}

sync_worktree_atomic() {
    local worktree_name="$1"
    local worktree_path="$SWARMSH_BASE_PATH/$worktree_name"
    
    echo "Syncing worktree '$worktree_name'"
    
    # Check if worktree exists
    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree '$worktree_name' not found at '$worktree_path'" >&2
        log_worktree_telemetry "sync" "$worktree_name" "failed"
        return 1
    fi
    
    # Sync with upstream
    cd "$worktree_path"
    if git pull --rebase 2>/dev/null; then
        echo "Worktree '$worktree_name' synced successfully"
        update_worktree_metadata "$worktree_name" "last_sync" "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
        return 0
    else
        echo "Error: Failed to sync worktree '$worktree_name'" >&2
        log_worktree_telemetry "sync" "$worktree_name" "failed"
        return 1
    fi
}

backup_worktree_atomic() {
    local worktree_name="$1"
    local worktree_path="$SWARMSH_BASE_PATH/$worktree_name"
    local backup_path="$SWARMSH_BASE_PATH/.backups/$worktree_name_$(date +%Y%m%d_%H%M%S)"
    
    echo "Backing up worktree '$worktree_name'"
    
    # Check if worktree exists
    if [[ ! -d "$worktree_path" ]]; then
        echo "Error: Worktree '$worktree_name' not found at '$worktree_path'" >&2
        log_worktree_telemetry "backup" "$worktree_name" "failed"
        return 1
    fi
    
    # Create backup directory
    mkdir -p "$(dirname "$backup_path")"
    
    # Create backup
    if cp -r "$worktree_path" "$backup_path" 2>/dev/null; then
        echo "Worktree '$worktree_name' backed up to '$backup_path'"
        update_worktree_metadata "$worktree_name" "last_backup" "$backup_path"
        return 0
    else
        echo "Error: Failed to backup worktree '$worktree_name'" >&2
        log_worktree_telemetry "backup" "$worktree_name" "failed"
        return 1
    fi
}

restore_worktree_atomic() {
    local worktree_name="$1"
    local backup_identifier="${2:-latest}"
    local worktree_path="$SWARMSH_BASE_PATH/$worktree_name"
    local backup_base="$SWARMSH_BASE_PATH/.backups"
    
    echo "Restoring worktree '$worktree_name' from backup '$backup_identifier'"
    
    # Find backup to restore
    local backup_path
    if [[ "$backup_identifier" == "latest" ]]; then
        backup_path=$(find "$backup_base" -name "${worktree_name}_*" -type d | sort | tail -n1)
    else
        backup_path="$backup_base/$backup_identifier"
    fi
    
    if [[ ! -d "$backup_path" ]]; then
        echo "Error: Backup not found for worktree '$worktree_name'" >&2
        log_worktree_telemetry "restore" "$worktree_name" "failed"
        return 1
    fi
    
    # Remove existing worktree if it exists
    if [[ -d "$worktree_path" ]]; then
        remove_worktree_atomic "$worktree_name" "true"
    fi
    
    # Restore from backup
    if cp -r "$backup_path" "$worktree_path" 2>/dev/null; then
        echo "Worktree '$worktree_name' restored from '$backup_path'"
        update_worktree_metadata "$worktree_name" "last_restore" "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
        return 0
    else
        echo "Error: Failed to restore worktree '$worktree_name'" >&2
        log_worktree_telemetry "restore" "$worktree_name" "failed"
        return 1
    fi
}

# Metadata management
create_worktree_metadata() {
    local worktree_name="$1"
    local branch_name="$2"
    local worktree_path="$3"
    local metadata_file="$SWARMSH_COORDINATION_DIR/worktree_${worktree_name}.json"
    
    local metadata=$(cat << EOF
{
    "name": "$worktree_name",
    "path": "$worktree_path",
    "branch": "$branch_name",
    "status": "active",
    "coordination_pattern": "atomic",
    "created_at": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
    "last_activity": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
    "agent_assignments": [],
    "metrics": {
        "commits_count": 0,
        "files_changed": 0,
        "coordination_events": 1,
        "sync_frequency_hours": 24.0,
        "disk_usage_mb": 0,
        "agent_utilization": 0.0
    }
}
EOF
)
    
    echo "$metadata" > "$metadata_file"
}

update_worktree_metadata() {
    local worktree_name="$1"
    local key="$2"
    local value="$3"
    local metadata_file="$SWARMSH_COORDINATION_DIR/worktree_${worktree_name}.json"
    
    if [[ -f "$metadata_file" ]]; then
        # Simple JSON update using temporary file
        local temp_file=$(mktemp)
        if command -v jq >/dev/null 2>&1; then
            jq --arg key "$key" --arg value "$value" '.[$key] = $value' "$metadata_file" > "$temp_file"
            mv "$temp_file" "$metadata_file"
        else
            # Fallback: update last_activity timestamp
            sed -i.bak "s/\"last_activity\": \"[^\"]*\"/\"last_activity\": \"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\"/" "$metadata_file"
            rm -f "$metadata_file.bak"
        fi
    fi
}

remove_worktree_metadata() {
    local worktree_name="$1"
    local metadata_file="$SWARMSH_COORDINATION_DIR/worktree_${worktree_name}.json"
    
    if [[ -f "$metadata_file" ]]; then
        rm -f "$metadata_file"
    fi
}

# List operations
list_worktrees() {
    echo "SwarmSH v2 Worktree Management - Active Worktrees:"
    echo "================================================="
    
    # Use git worktree list if available
    if git worktree list --porcelain >/dev/null 2>&1; then
        git worktree list --porcelain | while IFS= read -r line; do
            if [[ "$line" =~ ^worktree\ (.+)$ ]]; then
                local path="${BASH_REMATCH[1]}"
                local name=$(basename "$path")
                echo "Name: $name"
                echo "Path: $path"
            elif [[ "$line" =~ ^branch\ (.+)$ ]]; then
                echo "Branch: ${BASH_REMATCH[1]}"
                echo "---"
            fi
        done
    else
        echo "No git repository found or git worktree not available"
    fi
    
    # Show coordination metadata if available
    if [[ -d "$SWARMSH_COORDINATION_DIR" ]]; then
        echo ""
        echo "Coordination Status:"
        echo "==================="
        for metadata_file in "$SWARMSH_COORDINATION_DIR"/worktree_*.json; do
            if [[ -f "$metadata_file" ]]; then
                local worktree_name=$(basename "$metadata_file" .json | sed 's/^worktree_//')
                echo "Worktree: $worktree_name"
                if command -v jq >/dev/null 2>&1; then
                    jq -r '"Status: " + .status + ", Pattern: " + .coordination_pattern + ", Last Activity: " + .last_activity' "$metadata_file"
                else
                    echo "Metadata available (install jq for detailed view)"
                fi
                echo "---"
            fi
        done
    fi
}

show_worktree_status() {
    local worktree_name="$1"
    local metadata_file="$SWARMSH_COORDINATION_DIR/worktree_${worktree_name}.json"
    
    echo "SwarmSH v2 Worktree Status: $worktree_name"
    echo "=========================================="
    
    if [[ -f "$metadata_file" ]]; then
        if command -v jq >/dev/null 2>&1; then
            jq '.' "$metadata_file"
        else
            cat "$metadata_file"
        fi
    else
        echo "No metadata found for worktree '$worktree_name'"
        
        # Try to get basic git worktree info
        local worktree_path="$SWARMSH_BASE_PATH/$worktree_name"
        if [[ -d "$worktree_path" ]]; then
            echo "Path: $worktree_path"
            cd "$worktree_path"
            echo "Branch: $(git branch --show-current 2>/dev/null || echo 'unknown')"
            echo "Status: $(git status --porcelain | wc -l) files changed"
        else
            echo "Worktree not found"
        fi
    fi
}

# Coordination patterns implementation
{% for pattern in coordination_patterns %}
coordinate_{{ pattern | lower | replace(" ", "_") }}() {
    local worktree_names=("$@")
    local coordination_epoch=$(generate_coordination_epoch)
    
    echo "Initiating {{ pattern }} coordination for ${#worktree_names[@]} worktrees"
    log_worktree_telemetry "coordinate_{{ pattern | lower | replace(" ", "_") }}" "multiple" "started"
    
    {% if pattern == "Scrum at Scale" %}
    # Sprint planning and team synchronization
    for worktree_name in "${worktree_names[@]}"; do
        echo "Assigning sprint work to worktree: $worktree_name"
        update_worktree_metadata "$worktree_name" "coordination_pattern" "scrum_at_scale"
    done
    {% elif pattern == "Roberts Rules" %}
    # Formal voting and decision making
    local votes_for=0
    local votes_against=0
    
    for worktree_name in "${worktree_names[@]}"; do
        echo "Collecting vote from worktree: $worktree_name"
        # Simulate voting (in real implementation, would query worktree agents)
        if (( RANDOM % 2 )); then
            ((votes_for++))
        else
            ((votes_against++))
        fi
    done
    
    if (( votes_for > votes_against )); then
        echo "Coordination proposal APPROVED: $votes_for for, $votes_against against"
    else
        echo "Coordination proposal REJECTED: $votes_for for, $votes_against against"
    fi
    {% elif pattern == "Real-time" %}
    # High-frequency coordination
    echo "Real-time coordination epoch: $coordination_epoch"
    for worktree_name in "${worktree_names[@]}"; do
        echo "Real-time sync: $worktree_name"
        update_worktree_metadata "$worktree_name" "coordination_pattern" "realtime"
    done
    {% elif pattern == "Atomic" %}
    # Zero-conflict atomic operations
    for worktree_name in "${worktree_names[@]}"; do
        echo "Atomic coordination check: $worktree_name"
        update_worktree_metadata "$worktree_name" "coordination_pattern" "atomic"
    done
    {% endif %}
    
    log_worktree_telemetry "coordinate_{{ pattern | lower | replace(" ", "_") }}" "multiple" "completed"
}
{% endfor %}

# AI integration placeholders
ai_optimize_worktree_distribution() {
    echo "AI optimization for worktree distribution"
    log_worktree_telemetry "ai_optimization" "system" "started"
    
    # Placeholder for AI integration
    local worktree_count=$(find "$SWARMSH_BASE_PATH" -maxdepth 1 -type d | wc -l)
    echo "Analyzing $worktree_count worktrees for optimization opportunities"
    
    # Generate mock recommendations
    echo "AI Recommendations:"
    echo "- Consider consolidating low-activity worktrees"
    echo "- Increase sync frequency for high-activity worktrees"
    echo "- Distribute agent assignments more evenly"
    
    log_worktree_telemetry "ai_optimization" "system" "completed"
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    
    case "$command" in
        "create")
            if [[ $# -lt 2 ]]; then
                echo "Usage: $0 create <worktree_name> [branch_name]" >&2
                exit 1
            fi
            atomic_worktree_operation "create" "$2" "${3:-$2}"
            ;;
        "remove"|"rm")
            if [[ $# -lt 2 ]]; then
                echo "Usage: $0 remove <worktree_name> [force]" >&2
                exit 1
            fi
            atomic_worktree_operation "remove" "$2" "${3:-false}"
            ;;
        "sync")
            if [[ $# -lt 2 ]]; then
                echo "Usage: $0 sync <worktree_name>" >&2
                exit 1
            fi
            atomic_worktree_operation "sync" "$2"
            ;;
        "backup")
            if [[ $# -lt 2 ]]; then
                echo "Usage: $0 backup <worktree_name>" >&2
                exit 1
            fi
            atomic_worktree_operation "backup" "$2"
            ;;
        "restore")
            if [[ $# -lt 2 ]]; then
                echo "Usage: $0 restore <worktree_name> [backup_identifier]" >&2
                exit 1
            fi
            atomic_worktree_operation "restore" "$2" "${3:-latest}"
            ;;
        "list"|"ls")
            list_worktrees
            ;;
        "status")
            if [[ $# -lt 2 ]]; then
                echo "Usage: $0 status <worktree_name>" >&2
                exit 1
            fi
            show_worktree_status "$2"
            ;;
        "coordinate")
            if [[ $# -lt 3 ]]; then
                echo "Usage: $0 coordinate <pattern> <worktree1> [worktree2] ..." >&2
                echo "Patterns: {{ coordination_patterns | join(', ') | lower }}"
                exit 1
            fi
            local pattern="$2"
            shift 2
            case "$pattern" in
                {% for pattern in coordination_patterns %}
                "{{ pattern | lower | replace(" ", "_") }}")
                    coordinate_{{ pattern | lower | replace(" ", "_") }} "$@"
                    ;;
                {% endfor %}
                *)
                    echo "Unknown coordination pattern: $pattern" >&2
                    echo "Available patterns: {{ coordination_patterns | join(', ') | lower }}"
                    exit 1
                    ;;
            esac
            ;;
        "ai-optimize")
            ai_optimize_worktree_distribution
            ;;
        "telemetry")
            if [[ -f "$SWARMSH_TELEMETRY_FILE" ]]; then
                echo "SwarmSH v2 Worktree Telemetry:"
                echo "=============================="
                tail -n 20 "$SWARMSH_TELEMETRY_FILE"
            else
                echo "No telemetry data available"
            fi
            ;;
        "help"|"-h"|"--help")
            cat << EOF
SwarmSH v2 Worktree Management - Complete Lifecycle Support
===========================================================

USAGE:
    $0 <command> [arguments]

COMMANDS:
    create <name> [branch]         Create new worktree
    remove <name> [force]          Remove worktree (use 'true' for force)
    sync <name>                    Synchronize worktree with upstream
    backup <name>                  Create worktree backup
    restore <name> [backup_id]     Restore from backup (default: latest)
    list                          List all worktrees
    status <name>                 Show detailed worktree status
    coordinate <pattern> <names>   Coordinate multiple worktrees
    ai-optimize                   AI-enhanced optimization recommendations
    telemetry                     Show recent telemetry data
    help                          Show this help message

COORDINATION PATTERNS:
    {{ coordination_patterns | join(', ') | lower }}

ENVIRONMENT VARIABLES:
    SWARMSH_BASE_PATH            Base directory for worktrees (default: ./worktrees)
    SWARMSH_COORDINATION_DIR     Coordination metadata directory (default: /tmp/swarmsh-coordination)
    SWARMSH_AGENT_ID            Agent identifier (default: auto-generated)

FEATURES:
    • Zero-conflict guarantees with nanosecond-precision coordination
    • Complete lifecycle management (create, sync, backup, restore)
    • AI-enhanced optimization and decision making
    • OTEL-compatible telemetry and observability
    • Multiple coordination patterns (Scrum at Scale, Roberts Rules, etc.)
    • Atomic operations with file-based locking
    • Shell export of full Rust functionality

For more information, see SwarmSH v2 documentation.
EOF
            ;;
        *)
            echo "Unknown command: $command" >&2
            echo "Use '$0 help' for usage information" >&2
            exit 1
            ;;
    esac
}

# Execute main function with all arguments
main "$@"