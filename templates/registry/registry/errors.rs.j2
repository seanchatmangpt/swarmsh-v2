//! Generated error types for SwarmSH v2 telemetry
//! 
//! This code is generated by OTEL Weaver from semantic conventions.
//! DO NOT EDIT MANUALLY.
//!
//! Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
//! Generation timestamp: {{ params.generation_timestamp | default(now()) }}

use std::fmt;
use thiserror::Error;

/// Main telemetry error type
#[derive(Error, Debug, Clone)]
pub enum TelemetryError {
    /// Validation error with details
    #[error("Validation error: {0}")]
    ValidationError(String),

    /// Missing required attribute
    #[error("Missing required attribute: {attribute} for {context}")]
    MissingRequiredAttribute {
        attribute: String,
        context: String,
    },

    /// Invalid attribute type
    #[error("Invalid attribute type for '{attribute}': expected {expected}, got {actual}")]
    InvalidAttributeType {
        attribute: String,
        expected: String,
        actual: String,
    },

    /// Invalid attribute value
    #[error("Invalid value '{value}' for attribute '{attribute}': {reason}")]
    InvalidAttributeValue {
        attribute: String,
        value: String,
        reason: String,
    },

    /// Span building error
    #[error("Failed to build span '{name}': {reason}")]
    SpanBuildError {
        name: String,
        reason: String,
    },

    /// Metric recording error
    #[error("Failed to record metric '{name}': {reason}")]
    MetricError {
        name: String,
        reason: String,
    },

    /// Event recording error
    #[error("Failed to record event '{name}': {reason}")]
    EventError {
        name: String,
        reason: String,
    },

    /// Configuration error
    #[error("Telemetry configuration error: {0}")]
    ConfigurationError(String),

    /// Export error
    #[error("Failed to export telemetry data: {0}")]
    ExportError(String),

    /// Initialization error
    #[error("Failed to initialize telemetry: {0}")]
    InitializationError(String),

    /// SDK error
    #[error("OpenTelemetry SDK error: {0}")]
    SdkError(String),

    /// Shell export error
    #[error("Failed to export to shell: {0}")]
    ShellExportError(String),

    /// Unknown error
    #[error("Unknown telemetry error: {0}")]
    Unknown(String),
}

impl TelemetryError {
    /// Create a validation error from multiple validation failures
    pub fn from_validation_errors(errors: Vec<String>) -> Self {
        Self::ValidationError(errors.join("; "))
    }

    /// Check if this is a critical error that should halt execution
    pub fn is_critical(&self) -> bool {
        matches!(
            self,
            Self::InitializationError(_) | Self::ConfigurationError(_) | Self::SdkError(_)
        )
    }

    /// Check if this error can be safely ignored in production
    pub fn is_ignorable(&self) -> bool {
        matches!(
            self,
            Self::MissingRequiredAttribute { .. } | Self::InvalidAttributeValue { .. }
        )
    }

    /// Get error code for structured logging
    pub fn error_code(&self) -> &'static str {
        match self {
            Self::ValidationError(_) => "TELEMETRY_VALIDATION_ERROR",
            Self::MissingRequiredAttribute { .. } => "TELEMETRY_MISSING_ATTR",
            Self::InvalidAttributeType { .. } => "TELEMETRY_INVALID_TYPE",
            Self::InvalidAttributeValue { .. } => "TELEMETRY_INVALID_VALUE",
            Self::SpanBuildError { .. } => "TELEMETRY_SPAN_BUILD",
            Self::MetricError { .. } => "TELEMETRY_METRIC",
            Self::EventError { .. } => "TELEMETRY_EVENT",
            Self::ConfigurationError(_) => "TELEMETRY_CONFIG",
            Self::ExportError(_) => "TELEMETRY_EXPORT",
            Self::InitializationError(_) => "TELEMETRY_INIT",
            Self::SdkError(_) => "TELEMETRY_SDK",
            Self::ShellExportError(_) => "TELEMETRY_SHELL_EXPORT",
            Self::Unknown(_) => "TELEMETRY_UNKNOWN",
        }
    }
}

/// Result type for telemetry operations
pub type TelemetryResult<T> = Result<T, TelemetryError>;

/// Domain-specific error types
{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
/// Errors specific to {{ group.id }}
#[derive(Error, Debug, Clone)]
pub enum {{ group.id | replace(".", "_") | pascal_case }}Error {
      {% for attr in group.attributes %}
        {% if attr.requirement_level == "required" %}
    /// Missing {{ attr.id }}
    #[error("Missing required attribute '{{ attr.id }}' ({{ attr.brief }})")]
    Missing{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | pascal_case }},
        {% endif %}
      {% endfor %}

    /// Generic validation error
    #[error("{{ group.id }} validation error: {0}")]
    ValidationError(String),

    /// Invalid operation
    #[error("Invalid {{ group.id }} operation: {0}")]
    InvalidOperation(String),
}

impl From<{{ group.id | replace(".", "_") | pascal_case }}Error> for TelemetryError {
    fn from(err: {{ group.id | replace(".", "_") | pascal_case }}Error) -> Self {
        match err {
            {% for attr in group.attributes %}
              {% if attr.requirement_level == "required" %}
            {{ group.id | replace(".", "_") | pascal_case }}Error::Missing{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | pascal_case }} => {
                Self::MissingRequiredAttribute {
                    attribute: "{{ attr.id }}".to_string(),
                    context: "{{ group.id }}".to_string(),
                }
            }
              {% endif %}
            {% endfor %}
            {{ group.id | replace(".", "_") | pascal_case }}Error::ValidationError(msg) => {
                Self::ValidationError(format!("{{ group.id }}: {}", msg))
            }
            {{ group.id | replace(".", "_") | pascal_case }}Error::InvalidOperation(msg) => {
                Self::ValidationError(format!("{{ group.id }} invalid operation: {}", msg))
            }
        }
    }
}

    {% endfor %}
  {% endif %}
{% endfor %}

/// Error recovery strategies
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ErrorRecoveryStrategy {
    /// Log and continue
    LogAndContinue,
    /// Use default value
    UseDefault,
    /// Retry operation
    Retry { max_attempts: usize },
    /// Fail fast
    FailFast,
    /// Skip operation
    Skip,
}

/// Error context for detailed diagnostics
#[derive(Debug, Clone)]
pub struct ErrorContext {
    pub domain: String,
    pub operation: String,
    pub attributes: std::collections::HashMap<String, String>,
    pub timestamp: std::time::SystemTime,
    pub recovery_strategy: ErrorRecoveryStrategy,
}

impl ErrorContext {
    /// Create new error context
    pub fn new(domain: impl Into<String>, operation: impl Into<String>) -> Self {
        Self {
            domain: domain.into(),
            operation: operation.into(),
            attributes: std::collections::HashMap::new(),
            timestamp: std::time::SystemTime::now(),
            recovery_strategy: ErrorRecoveryStrategy::LogAndContinue,
        }
    }

    /// Add attribute to context
    pub fn with_attribute(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.attributes.insert(key.into(), value.into());
        self
    }

    /// Set recovery strategy
    pub fn with_recovery(mut self, strategy: ErrorRecoveryStrategy) -> Self {
        self.recovery_strategy = strategy;
        self
    }

    /// Apply recovery strategy to an error
    pub fn recover<T>(&self, error: TelemetryError, default: T) -> Result<T, TelemetryError> {
        match self.recovery_strategy {
            ErrorRecoveryStrategy::LogAndContinue => {
                tracing::warn!(
                    domain = %self.domain,
                    operation = %self.operation,
                    error = %error,
                    "Telemetry error occurred, continuing with default"
                );
                Ok(default)
            }
            ErrorRecoveryStrategy::UseDefault => Ok(default),
            ErrorRecoveryStrategy::FailFast => Err(error),
            ErrorRecoveryStrategy::Skip => {
                tracing::debug!(
                    domain = %self.domain,
                    operation = %self.operation,
                    "Skipping operation due to error"
                );
                Ok(default)
            }
            ErrorRecoveryStrategy::Retry { .. } => {
                // Retry logic would be implemented by the caller
                Err(error)
            }
        }
    }
}

/// Extension trait for adding context to errors
pub trait ErrorContextExt {
    /// Add context to this error
    fn with_context(self, context: ErrorContext) -> TelemetryError;
}

impl ErrorContextExt for TelemetryError {
    fn with_context(self, context: ErrorContext) -> TelemetryError {
        let msg = format!(
            "{} (domain: {}, operation: {}, attributes: {:?})",
            self, context.domain, context.operation, context.attributes
        );
        TelemetryError::Unknown(msg)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_error_codes() {
        assert_eq!(
            TelemetryError::ValidationError("test".to_string()).error_code(),
            "TELEMETRY_VALIDATION_ERROR"
        );
        
        assert_eq!(
            TelemetryError::InitializationError("test".to_string()).error_code(),
            "TELEMETRY_INIT"
        );
    }

    #[test]
    fn test_error_criticality() {
        assert!(TelemetryError::InitializationError("test".to_string()).is_critical());
        assert!(!TelemetryError::MissingRequiredAttribute {
            attribute: "test".to_string(),
            context: "test".to_string(),
        }.is_critical());
    }

    #[test]
    fn test_domain_specific_errors() {
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% if group.attributes | selectattr("requirement_level", "eq", "required") | list | length > 0 %}
        let err = {{ group.id | replace(".", "_") | pascal_case }}Error::Missing{{ group.attributes | selectattr("requirement_level", "eq", "required") | first | attr("id") | replace(group.id ~ ".", "") | replace(".", "_") | pascal_case }};
        let telemetry_err: TelemetryError = err.into();
        assert!(matches!(telemetry_err, TelemetryError::MissingRequiredAttribute { .. }));
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
    }

    #[test]
    fn test_error_recovery() {
        let context = ErrorContext::new("test", "operation")
            .with_recovery(ErrorRecoveryStrategy::UseDefault);
        
        let error = TelemetryError::ValidationError("test".to_string());
        let result = context.recover(error, 42);
        
        assert_eq!(result.unwrap(), 42);
    }
}