//! Generated span builders for SwarmSH v2 telemetry
//! 
//! This code is generated by OTEL Weaver from semantic conventions.
//! DO NOT EDIT MANUALLY.
//!
//! Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
//! Generation timestamp: {{ params.generation_timestamp | default(now()) }}

use opentelemetry::{
    trace::{Span, SpanContext, SpanKind, Status, StatusCode, TraceContextExt, Tracer},
    Context, KeyValue,
};
use std::borrow::Cow;
use std::collections::HashMap;
use std::sync::Arc;
use tracing::{span, Level};

use crate::telemetry::attributes::*;
use crate::telemetry::errors::TelemetryError;
use crate::telemetry::validation::*;

{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
      {% if group.type == "span" %}
/// {{ group.brief | comment("rust") }}
{% if group.note %}
/// 
{{ group.note | comment("rust") }}
{% endif %}
#[derive(Debug, Clone)]
pub struct {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder {
    /// Span name
    span_name: String,
    /// Span kind
    span_kind: SpanKind,
    /// Span attributes
    attributes: HashMap<String, KeyValue>,
    /// Validation errors
    validation_errors: Vec<String>,
    /// Whether to enforce required attributes
    enforce_required: bool,
}

impl {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder {
    /// Create a new span builder
    pub fn new(span_name: impl Into<String>) -> Self {
        Self {
            span_name: span_name.into(),
            span_kind: SpanKind::Internal,
            attributes: HashMap::new(),
            validation_errors: Vec::new(),
            enforce_required: true,
        }
    }

    /// Set the span kind
    pub fn with_kind(mut self, kind: SpanKind) -> Self {
        self.span_kind = kind;
        self
    }

    /// Disable required attribute enforcement (for testing)
    pub fn without_required_enforcement(mut self) -> Self {
        self.enforce_required = false;
        self
    }

        {% for attr in group.attributes %}
    /// Set {{ attr.id }} attribute
    /// 
    /// {{ attr.brief }}
          {% if attr.note %}
    /// 
    {{ attr.note | comment("rust") | indent(4) }}
          {% endif %}
          {% if attr.examples %}
    /// 
    /// # Examples
    /// 
            {% for example in attr.examples %}
    /// - `{{ example }}`
            {% endfor %}
          {% endif %}
          {% if attr.requirement_level == "required" %}
    /// 
    /// **Required attribute**
          {% endif %}
    pub fn with_{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}(mut self, value: {{ attr.type | rust_type }}) -> Self {
        {% if attr.type == "string" %}
        self.attributes.insert(
            "{{ attr.id }}".to_string(),
            KeyValue::new("{{ attr.id }}", value.to_string())
        );
        {% elif attr.type == "int" %}
        self.attributes.insert(
            "{{ attr.id }}".to_string(),
            KeyValue::new("{{ attr.id }}", value)
        );
        {% elif attr.type == "double" %}
        self.attributes.insert(
            "{{ attr.id }}".to_string(),
            KeyValue::new("{{ attr.id }}", value)
        );
        {% elif attr.type == "boolean" %}
        self.attributes.insert(
            "{{ attr.id }}".to_string(),
            KeyValue::new("{{ attr.id }}", value)
        );
        {% elif attr.type == "string[]" %}
        self.attributes.insert(
            "{{ attr.id }}".to_string(),
            KeyValue::new("{{ attr.id }}", value.into_iter().map(|s| s.to_string()).collect::<Vec<_>>())
        );
        {% else %}
        self.attributes.insert(
            "{{ attr.id }}".to_string(),
            KeyValue::new("{{ attr.id }}", format!("{:?}", value))
        );
        {% endif %}
        self
    }

        {% endfor %}

    /// Add a custom attribute
    pub fn with_attribute(mut self, key: impl Into<String>, value: impl Into<KeyValue>) -> Self {
        self.attributes.insert(key.into(), value.into());
        self
    }

    /// Add multiple attributes
    pub fn with_attributes<I>(mut self, attributes: I) -> Self
    where
        I: IntoIterator<Item = (String, KeyValue)>,
    {
        self.attributes.extend(attributes);
        self
    }

    /// Validate the span builder
    pub fn validate(&mut self) -> Result<(), TelemetryError> {
        self.validation_errors.clear();

        {% for attr in group.attributes %}
          {% if attr.requirement_level == "required" %}
        // Check required attribute: {{ attr.id }}
        if self.enforce_required && !self.attributes.contains_key("{{ attr.id }}") {
            self.validation_errors.push(format!(
                "Missing required attribute: {{ attr.id }} ({{ attr.brief }})"
            ));
        }
          {% endif %}
        {% endfor %}

        // Validate attribute constraints
        for (key, value) in &self.attributes {
            match key.as_str() {
                {% for attr in group.attributes %}
                  {% if attr.type == "string" and attr.examples %}
                "{{ attr.id }}" => {
                    // Validate against known examples if strict validation is enabled
                    if let Some(str_val) = value.as_str() {
                        let valid_values = vec![{{ attr.examples | map('quote') | join(", ") }}];
                        if !valid_values.is_empty() && !valid_values.contains(&str_val) {
                            // This is a warning, not an error
                            tracing::warn!(
                                attribute = "{{ attr.id }}",
                                value = %str_val,
                                valid_values = ?valid_values,
                                "Attribute value not in examples list"
                            );
                        }
                    }
                }
                  {% endif %}
                {% endfor %}
                _ => {}
            }
        }

        if !self.validation_errors.is_empty() {
            return Err(TelemetryError::ValidationError(
                self.validation_errors.join("; ")
            ));
        }

        Ok(())
    }

    /// Build the span using the tracing crate
    pub fn build_tracing(mut self) -> Result<tracing::Span, TelemetryError> {
        self.validate()?;

        let span = span!(
            Level::INFO,
            "{{ group.id }}",
            otel.name = %self.span_name,
            otel.kind = ?self.span_kind,
            {% for attr in group.attributes %}
              {% if attr.requirement_level == "required" %}
            {{ '"' ~ attr.id ~ '"' }} = tracing::field::Empty,
              {% endif %}
            {% endfor %}
        );

        // Set attributes on the span
        span.in_scope(|| {
            for (key, value) in self.attributes {
                match key.as_str() {
                    {% for attr in group.attributes %}
                    "{{ attr.id }}" => {
                        span.record("{{ attr.id }}", &tracing::field::display(&value));
                    }
                    {% endfor %}
                    _ => {
                        // Custom attribute
                        tracing::info!(
                            attribute.key = %key,
                            attribute.value = %value,
                            "Custom span attribute"
                        );
                    }
                }
            }
        });

        Ok(span)
    }

    /// Build the span using OpenTelemetry directly
    pub fn build_otel<T: Tracer>(self, tracer: &T) -> Result<T::Span, TelemetryError> {
        let mut self_mut = self;
        self_mut.validate()?;

        let mut span_builder = tracer.span_builder(self_mut.span_name.clone())
            .with_kind(self_mut.span_kind);

        // Convert attributes to OpenTelemetry KeyValue pairs
        let otel_attributes: Vec<KeyValue> = self_mut.attributes
            .into_iter()
            .map(|(_, v)| v)
            .collect();

        span_builder = span_builder.with_attributes(otel_attributes);

        Ok(span_builder.start(tracer))
    }

    /// Get the span name
    pub fn span_name(&self) -> &str {
        &self.span_name
    }

    /// Get the span kind
    pub fn span_kind(&self) -> SpanKind {
        self.span_kind
    }

    /// Get a reference to the attributes
    pub fn attributes(&self) -> &HashMap<String, KeyValue> {
        &self.attributes
    }

    /// Check if all required attributes are set
    pub fn is_valid(&self) -> bool {
        let mut temp = self.clone();
        temp.validate().is_ok()
    }
}

impl Default for {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder {
    fn default() -> Self {
        Self::new("{{ group.id }}.default")
    }
}

      {% endif %}
    {% endfor %}
  {% endif %}
{% endfor %}

/// Create a span builder for a specific domain
pub fn span_builder_for(domain: &str, operation: &str) -> Box<dyn SpanBuilderTrait> {
    match domain {
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% if group.type == "span" %}
        "{{ group.id }}" => Box::new({{ group.id | replace(".", "_") | pascal_case }}SpanBuilder::new(operation)),
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        _ => Box::new(GenericSpanBuilder::new(format!("{}.{}", domain, operation))),
    }
}

/// Trait for all span builders
pub trait SpanBuilderTrait: Send + Sync {
    /// Get the span name
    fn span_name(&self) -> &str;
    
    /// Get the span kind
    fn span_kind(&self) -> SpanKind;
    
    /// Validate the span builder
    fn validate(&mut self) -> Result<(), TelemetryError>;
    
    /// Build using tracing
    fn build_tracing(self: Box<Self>) -> Result<tracing::Span, TelemetryError>;
}

/// Generic span builder for domains not covered by semantic conventions
#[derive(Debug, Clone)]
pub struct GenericSpanBuilder {
    span_name: String,
    span_kind: SpanKind,
    attributes: HashMap<String, KeyValue>,
}

impl GenericSpanBuilder {
    pub fn new(span_name: impl Into<String>) -> Self {
        Self {
            span_name: span_name.into(),
            span_kind: SpanKind::Internal,
            attributes: HashMap::new(),
        }
    }
}

impl SpanBuilderTrait for GenericSpanBuilder {
    fn span_name(&self) -> &str {
        &self.span_name
    }
    
    fn span_kind(&self) -> SpanKind {
        self.span_kind
    }
    
    fn validate(&mut self) -> Result<(), TelemetryError> {
        Ok(())
    }
    
    fn build_tracing(self: Box<Self>) -> Result<tracing::Span, TelemetryError> {
        Ok(span!(Level::INFO, "generic", otel.name = %self.span_name))
    }
}

{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
      {% if group.type == "span" %}
impl SpanBuilderTrait for {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder {
    fn span_name(&self) -> &str {
        &self.span_name
    }
    
    fn span_kind(&self) -> SpanKind {
        self.span_kind
    }
    
    fn validate(&mut self) -> Result<(), TelemetryError> {
        self.validate()
    }
    
    fn build_tracing(self: Box<Self>) -> Result<tracing::Span, TelemetryError> {
        (*self).build_tracing()
    }
}
      {% endif %}
    {% endfor %}
  {% endif %}
{% endfor %}

#[cfg(test)]
mod tests {
    use super::*;

    {% for convention in ctx %}
      {% if convention.groups %}
        {% for group in convention.groups %}
          {% if group.type == "span" %}
    #[test]
    fn test_{{ group.id | replace(".", "_") | snake_case }}_span_builder() {
        let builder = {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder::new("test_operation")
            {% for attr in group.attributes %}
              {% if attr.requirement_level == "required" %}
                {% if attr.type == "string" %}
            .with_{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}("{{ attr.examples[0] | default("test_value") }}")
                {% elif attr.type == "int" %}
            .with_{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}({{ attr.examples[0] | default(1) }})
                {% elif attr.type == "boolean" %}
            .with_{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}(true)
                {% endif %}
              {% endif %}
            {% endfor %}
            ;

        assert!(builder.is_valid());
        assert_eq!(builder.span_name(), "test_operation");
    }

    #[test]
    fn test_{{ group.id | replace(".", "_") | snake_case }}_span_builder_missing_required() {
        let mut builder = {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder::new("test_operation");
        
        // Should fail validation due to missing required attributes
        assert!(builder.validate().is_err());
    }
          {% endif %}
        {% endfor %}
      {% endif %}
    {% endfor %}
}

// Custom Jinja2 filters would be implemented in the Rust code that processes these templates
// For example:
// - rust_type: converts semantic convention types to Rust types
// - quote: adds quotes around string values
// - comment: formats text as Rust comments