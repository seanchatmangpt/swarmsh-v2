#!/bin/bash
# Generated metric collection for SwarmSH v2 shell scripts
# 
# This code is generated by OTEL Weaver from semantic conventions.
# DO NOT EDIT MANUALLY.
#
# Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
# Generation timestamp: {{ params.generation_timestamp | default(now()) }}

# Enable strict error handling
set -euo pipefail

# Metrics state directory
METRICS_STATE_DIR="${METRICS_STATE_DIR:-/tmp/swarmsh/metrics}"
mkdir -p "$METRICS_STATE_DIR"

# Metrics export file
METRICS_EXPORT_FILE="${METRICS_EXPORT_FILE:-$METRICS_STATE_DIR/metrics.prom}"

# Domain-specific metric functions
{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
      {% if group.metrics %}

# {{ group.brief }} Metrics
        {% for metric in group.metrics %}

# Record {{ metric.id }}
# {{ metric.brief }}
record_{{ metric.id | replace(".", "_") }}() {
    local value="$1"
    shift
    
    # Parse labels
    local -a labels=()
    while [[ $# -gt 0 ]]; do
        if [[ "$1" =~ ^([^=]+)=(.*)$ ]]; then
            labels+=("${BASH_REMATCH[1]}=\"${BASH_REMATCH[2]}\"")
        fi
        shift
    done
    
    # Format labels
    local label_str=""
    if [[ ${#labels[@]} -gt 0 ]]; then
        label_str="{$(IFS=','; echo "${labels[*]}")}"
    fi
    
    # Record metric based on type
          {% if metric.instrument == "counter" %}
    increment_counter "{{ metric.id }}" "$value" "$label_str"
          {% elif metric.instrument == "gauge" %}
    set_gauge "{{ metric.id }}" "$value" "$label_str"
          {% elif metric.instrument == "histogram" %}
    observe_histogram "{{ metric.id }}" "$value" "$label_str"
          {% elif metric.instrument == "updowncounter" %}
    update_updown_counter "{{ metric.id }}" "$value" "$label_str"
          {% endif %}
}
        {% endfor %}

# Helper functions for {{ group.id }} metrics
init_{{ group.id | replace(".", "_") }}_metrics() {
    # Initialize metric files
        {% for metric in group.metrics %}
    init_metric "{{ metric.id }}" "{{ metric.instrument }}" "{{ metric.brief | escape }}"
        {% endfor %}
}

export_{{ group.id | replace(".", "_") }}_metrics() {
    local format="${1:-prometheus}"
    local output="${2:-/dev/stdout}"
    
    {
        echo "# {{ group.brief }}"
        {% for metric in group.metrics %}
        export_metric "{{ metric.id }}" "{{ metric.instrument }}" "$format"
        {% endfor %}
    } >> "$output"
}
      {% endif %}
    {% endfor %}
  {% endif %}
{% endfor %}

# Core metric functions
init_metric() {
    local metric_name="$1"
    local metric_type="$2"
    local description="$3"
    
    local metric_file="$METRICS_STATE_DIR/${metric_name//[.]/_}.metric"
    
    # Initialize metric file with metadata
    cat > "$metric_file" <<EOF
{
    "name": "$metric_name",
    "type": "$metric_type",
    "description": "$description",
    "created": "$(get_nano_timestamp)",
    "values": {}
}
EOF
}

# Counter operations
increment_counter() {
    local metric_name="$1"
    local increment="${2:-1}"
    local labels="${3:-}"
    
    local metric_file="$METRICS_STATE_DIR/${metric_name//[.]/_}.metric"
    local timestamp=$(get_nano_timestamp)
    
    # Create metric file if not exists
    if [[ ! -f "$metric_file" ]]; then
        init_metric "$metric_name" "counter" "Counter metric"
    fi
    
    # Update counter value
    local temp_file="${metric_file}.tmp"
    local label_key="${labels:-default}"
    
    jq --arg labels "$label_key" \
       --arg inc "$increment" \
       --arg ts "$timestamp" \
       '.values[$labels] = {
           value: ((.values[$labels].value // 0) + ($inc | tonumber)),
           timestamp: $ts
       }' "$metric_file" > "$temp_file" && mv "$temp_file" "$metric_file"
    
    echo "[METRIC] type=counter name=$metric_name value=+$increment labels=$labels"
}

# Gauge operations
set_gauge() {
    local metric_name="$1"
    local value="$2"
    local labels="${3:-}"
    
    local metric_file="$METRICS_STATE_DIR/${metric_name//[.]/_}.metric"
    local timestamp=$(get_nano_timestamp)
    
    # Create metric file if not exists
    if [[ ! -f "$metric_file" ]]; then
        init_metric "$metric_name" "gauge" "Gauge metric"
    fi
    
    # Set gauge value
    local temp_file="${metric_file}.tmp"
    local label_key="${labels:-default}"
    
    jq --arg labels "$label_key" \
       --arg val "$value" \
       --arg ts "$timestamp" \
       '.values[$labels] = {
           value: ($val | tonumber),
           timestamp: $ts
       }' "$metric_file" > "$temp_file" && mv "$temp_file" "$metric_file"
    
    echo "[METRIC] type=gauge name=$metric_name value=$value labels=$labels"
}

# Histogram operations
observe_histogram() {
    local metric_name="$1"
    local value="$2"
    local labels="${3:-}"
    
    local metric_file="$METRICS_STATE_DIR/${metric_name//[.]/_}.metric"
    local timestamp=$(get_nano_timestamp)
    
    # Create metric file if not exists
    if [[ ! -f "$metric_file" ]]; then
        init_metric "$metric_name" "histogram" "Histogram metric"
    fi
    
    # Add observation to histogram
    local temp_file="${metric_file}.tmp"
    local label_key="${labels:-default}"
    
    jq --arg labels "$label_key" \
       --arg val "$value" \
       --arg ts "$timestamp" \
       '.values[$labels] = {
           observations: ((.values[$labels].observations // []) + [($val | tonumber)]),
           count: ((.values[$labels].count // 0) + 1),
           sum: ((.values[$labels].sum // 0) + ($val | tonumber)),
           timestamp: $ts
       }' "$metric_file" > "$temp_file" && mv "$temp_file" "$metric_file"
    
    echo "[METRIC] type=histogram name=$metric_name value=$value labels=$labels"
}

# Export metric in various formats
export_metric() {
    local metric_name="$1"
    local metric_type="$2"
    local format="${3:-prometheus}"
    
    local metric_file="$METRICS_STATE_DIR/${metric_name//[.]/_}.metric"
    
    if [[ ! -f "$metric_file" ]]; then
        return 0
    fi
    
    case "$format" in
        prometheus)
            # Export in Prometheus format
            local metric_data=$(cat "$metric_file")
            local description=$(echo "$metric_data" | jq -r '.description')
            
            echo "# HELP $metric_name $description"
            echo "# TYPE $metric_name $metric_type"
            
            # Export each label combination
            echo "$metric_data" | jq -r '.values | to_entries[] | 
                "\(.key) \(.value.value)"' | while read -r labels value; do
                if [[ "$labels" == "default" ]]; then
                    echo "${metric_name} $value"
                else
                    echo "${metric_name}${labels} $value"
                fi
            done
            ;;
        json)
            # Export as JSON
            jq --arg name "$metric_name" '{name: $name} + .' "$metric_file"
            ;;
        *)
            echo "ERROR: Unknown export format: $format" >&2
            return 1
            ;;
    esac
}

# Export all metrics
export_all_metrics() {
    local format="${1:-prometheus}"
    local output="${2:-$METRICS_EXPORT_FILE}"
    
    {
        echo "# SwarmSH v2 Metrics Export"
        echo "# Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo ""
        
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% if group.metrics %}
        export_{{ group.id | replace(".", "_") }}_metrics "$format" "/dev/stdout"
        echo ""
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
    } > "$output"
    
    echo "Metrics exported to: $output"
}

# Metric aggregation helpers
calculate_histogram_percentile() {
    local metric_name="$1"
    local percentile="$2"
    local labels="${3:-default}"
    
    local metric_file="$METRICS_STATE_DIR/${metric_name//[.]/_}.metric"
    
    if [[ ! -f "$metric_file" ]]; then
        echo "0"
        return
    fi
    
    # Get observations and calculate percentile
    local observations=$(jq -r --arg labels "$labels" \
        '.values[$labels].observations // [] | sort | @csv' "$metric_file")
    
    if [[ -z "$observations" ]]; then
        echo "0"
        return
    fi
    
    # Simple percentile calculation (could be improved)
    echo "$observations" | awk -F',' -v p="$percentile" '{
        n = NF;
        idx = int(n * p / 100);
        if (idx < 1) idx = 1;
        if (idx > n) idx = n;
        print $idx
    }'
}

# Metric reset functions
reset_metric() {
    local metric_name="$1"
    local metric_file="$METRICS_STATE_DIR/${metric_name//[.]/_}.metric"
    
    if [[ -f "$metric_file" ]]; then
        local temp_file="${metric_file}.tmp"
        jq '.values = {}' "$metric_file" > "$temp_file" && mv "$temp_file" "$metric_file"
        echo "Reset metric: $metric_name"
    fi
}

reset_all_metrics() {
    for metric_file in "$METRICS_STATE_DIR"/*.metric; do
        if [[ -f "$metric_file" ]]; then
            local metric_name=$(basename "$metric_file" .metric)
            reset_metric "${metric_name//_/.}"
        fi
    done
}

# Metric push gateway support
push_metrics() {
    local gateway_url="${1:-$PROMETHEUS_PUSHGATEWAY_URL}"
    local job_name="${2:-swarmsh}"
    local instance="${3:-$(hostname)}"
    
    if [[ -z "$gateway_url" ]]; then
        echo "ERROR: No push gateway URL provided" >&2
        return 1
    fi
    
    # Export metrics to temporary file
    local temp_metrics="/tmp/swarmsh_metrics_push_$$.prom"
    export_all_metrics "prometheus" "$temp_metrics"
    
    # Push to gateway
    curl -s -X POST \
        -H "Content-Type: text/plain" \
        --data-binary "@$temp_metrics" \
        "${gateway_url}/metrics/job/${job_name}/instance/${instance}"
    
    local result=$?
    rm -f "$temp_metrics"
    
    if [[ $result -eq 0 ]]; then
        echo "Metrics pushed successfully to $gateway_url"
    else
        echo "ERROR: Failed to push metrics" >&2
        return 1
    fi
}

# Initialize metrics on script start
init_all_metrics() {
    {% for convention in ctx %}
      {% if convention.groups %}
        {% for group in convention.groups %}
          {% if group.metrics %}
    init_{{ group.id | replace(".", "_") }}_metrics
          {% endif %}
        {% endfor %}
      {% endif %}
    {% endfor %}
}

# Auto-initialize if METRICS_AUTO_INIT is set
if [[ "${METRICS_AUTO_INIT:-false}" == "true" ]]; then
    init_all_metrics
fi