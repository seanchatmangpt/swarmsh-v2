#!/bin/bash
# Generated span tracking for SwarmSH v2 shell scripts
# 
# This code is generated by OTEL Weaver from semantic conventions.
# DO NOT EDIT MANUALLY.
#
# Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
# Generation timestamp: {{ params.generation_timestamp | default(now()) }}

# Enable strict error handling
set -euo pipefail

# Span tracking state directory
SPAN_STATE_DIR="${SPAN_STATE_DIR:-/tmp/swarmsh/spans}"
mkdir -p "$SPAN_STATE_DIR"

# Active spans (associative array)
declare -A ACTIVE_SPANS

# Span ID generation
generate_span_id() {
    printf '%016x' $RANDOM$RANDOM
}

generate_trace_id() {
    printf '%032x' $RANDOM$RANDOM$RANDOM$RANDOM
}

# Get current span context
get_current_span() {
    echo "${CURRENT_SPAN_ID:-}"
}

# Set current span context
set_current_span() {
    export CURRENT_SPAN_ID="$1"
}

# Domain-specific span functions
{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
      {% if group.type == "span" %}

# {{ group.brief }}
start_{{ group.id | replace(".", "_") }}_span() {
    local span_name="${1:-{{ group.id }}.operation}"
    shift
    
    # Extract required attributes
    local -A attributes
        {% for attr in group.attributes %}
          {% if attr.requirement_level == "required" %}
    local {{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}=""
          {% endif %}
        {% endfor %}
    
    # Parse attributes
    while [[ $# -gt 0 ]]; do
        case "$1" in
            {% for attr in group.attributes %}
            --{{ attr.id | replace(group.id ~ ".", "") | replace(".", "-") }}=*)
                {{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}="${1#*=}"
                attributes["{{ attr.id }}"]="${1#*=}"
                ;;
            {% endfor %}
            *)
                echo "Unknown attribute: $1" >&2
                ;;
        esac
        shift
    done
    
    # Validate required attributes
        {% for attr in group.attributes %}
          {% if attr.requirement_level == "required" %}
    if [[ -z "${{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}" ]]; then
        echo "ERROR: Missing required attribute '{{ attr.id }}'" >&2
        return 1
    fi
          {% endif %}
        {% endfor %}
    
    # Generate IDs
    local span_id=$(generate_span_id)
    local trace_id="${TRACE_ID:-$(generate_trace_id)}"
    local parent_span_id="${CURRENT_SPAN_ID:-}"
    local start_time=$(get_nano_timestamp)
    
    # Create span file
    local span_file="$SPAN_STATE_DIR/${span_id}.span"
    cat > "$span_file" <<EOF
{
    "span_id": "$span_id",
    "trace_id": "$trace_id",
    "parent_span_id": "$parent_span_id",
    "span_name": "$span_name",
    "domain": "{{ group.id }}",
    "start_time": "$start_time",
    "attributes": {
        {% for attr in group.attributes %}
          {% if attr.requirement_level == "required" %}
        "{{ attr.id }}": "${{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}"{{ "," if not loop.last }}
          {% endif %}
        {% endfor %}
    }
}
EOF
    
    # Set as current span
    set_current_span "$span_id"
    export TRACE_ID="$trace_id"
    
    # Log span start
    echo "[SPAN_START] {{ group.id }}:$span_name span_id=$span_id trace_id=$trace_id"
    
    # Return span ID for later use
    echo "$span_id"
}

end_{{ group.id | replace(".", "_") }}_span() {
    local span_id="${1:-$CURRENT_SPAN_ID}"
    local status="${2:-OK}"
    local error_message="${3:-}"
    
    if [[ -z "$span_id" ]]; then
        echo "ERROR: No span ID provided" >&2
        return 1
    fi
    
    local span_file="$SPAN_STATE_DIR/${span_id}.span"
    if [[ ! -f "$span_file" ]]; then
        echo "ERROR: Span file not found: $span_file" >&2
        return 1
    fi
    
    # Read span data
    local start_time=$(grep '"start_time"' "$span_file" | cut -d'"' -f4)
    local end_time=$(get_nano_timestamp)
    local duration=$((end_time - start_time))
    
    # Update span file with end data
    local temp_file="${span_file}.tmp"
    jq --arg end_time "$end_time" \
       --arg duration "$duration" \
       --arg status "$status" \
       --arg error "$error_message" \
       '. + {end_time: $end_time, duration_ns: $duration, status: $status, error: $error}' \
       "$span_file" > "$temp_file" && mv "$temp_file" "$span_file"
    
    # Log span end
    echo "[SPAN_END] span_id=$span_id duration_ms=$((duration / 1000000)) status=$status"
    
    # Clear current span if it matches
    if [[ "$CURRENT_SPAN_ID" == "$span_id" ]]; then
        unset CURRENT_SPAN_ID
    fi
}

# Convenience function for {{ group.id }} operations
with_{{ group.id | replace(".", "_") }}_span() {
    local span_name="$1"
    shift
    
    # Start span
    local span_id=$(start_{{ group.id | replace(".", "_") }}_span "$span_name" "$@")
    
    # Execute remaining arguments as command
    local exit_code=0
    local error_message=""
    
    # Shift past the span attributes to get to the command
    local cmd_start=false
    local -a cmd_args=()
    for arg in "$@"; do
        if [[ "$cmd_start" == "true" ]]; then
            cmd_args+=("$arg")
        elif [[ "$arg" == "--" ]]; then
            cmd_start=true
        fi
    done
    
    if [[ ${#cmd_args[@]} -gt 0 ]]; then
        if ! "${cmd_args[@]}"; then
            exit_code=$?
            error_message="Command failed with exit code $exit_code"
        fi
    fi
    
    # End span
    if [[ $exit_code -eq 0 ]]; then
        end_{{ group.id | replace(".", "_") }}_span "$span_id" "OK"
    else
        end_{{ group.id | replace(".", "_") }}_span "$span_id" "ERROR" "$error_message"
    fi
    
    return $exit_code
}
      {% endif %}
    {% endfor %}
  {% endif %}
{% endfor %}

# Generic span functions
start_span() {
    local domain="$1"
    local span_name="$2"
    shift 2
    
    case "$domain" in
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% if group.type == "span" %}
        "{{ group.id }}")
            start_{{ group.id | replace(".", "_") }}_span "$span_name" "$@"
            ;;
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        *)
            echo "ERROR: Unknown span domain: $domain" >&2
            return 1
            ;;
    esac
}

end_span() {
    local span_id="${1:-$CURRENT_SPAN_ID}"
    local status="${2:-OK}"
    
    if [[ -z "$span_id" ]]; then
        echo "ERROR: No span ID provided" >&2
        return 1
    fi
    
    # Determine domain from span file
    local span_file="$SPAN_STATE_DIR/${span_id}.span"
    if [[ -f "$span_file" ]]; then
        local domain=$(jq -r '.domain' "$span_file")
        case "$domain" in
            {% for convention in ctx %}
              {% if convention.groups %}
                {% for group in convention.groups %}
                  {% if group.type == "span" %}
            "{{ group.id }}")
                end_{{ group.id | replace(".", "_") }}_span "$span_id" "$status"
                ;;
                  {% endif %}
                {% endfor %}
              {% endif %}
            {% endfor %}
            *)
                # Generic span end
                local end_time=$(get_nano_timestamp)
                echo "[SPAN_END] span_id=$span_id status=$status"
                rm -f "$span_file"
                ;;
        esac
    fi
}

# Add span event
add_span_event() {
    local span_id="${1:-$CURRENT_SPAN_ID}"
    local event_name="$2"
    local event_message="$3"
    shift 3
    
    if [[ -z "$span_id" ]]; then
        echo "ERROR: No span ID provided" >&2
        return 1
    fi
    
    local span_file="$SPAN_STATE_DIR/${span_id}.span"
    if [[ ! -f "$span_file" ]]; then
        echo "ERROR: Span file not found" >&2
        return 1
    fi
    
    local timestamp=$(get_nano_timestamp)
    
    # Create event JSON
    local event_json=$(jq -n \
        --arg name "$event_name" \
        --arg message "$event_message" \
        --arg timestamp "$timestamp" \
        '{name: $name, message: $message, timestamp: $timestamp, attributes: {}}')
    
    # Add attributes
    while [[ $# -gt 0 ]]; do
        if [[ "$1" =~ ^([^=]+)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            event_json=$(echo "$event_json" | jq --arg k "$key" --arg v "$value" '.attributes[$k] = $v')
        fi
        shift
    done
    
    # Append event to span file
    local temp_file="${span_file}.tmp"
    jq --argjson event "$event_json" '.events = (.events // []) + [$event]' "$span_file" > "$temp_file" && mv "$temp_file" "$span_file"
    
    echo "[SPAN_EVENT] span_id=$span_id event=$event_name"
}

# Set span status
set_span_status() {
    local span_id="${1:-$CURRENT_SPAN_ID}"
    local status="$2"
    local description="${3:-}"
    
    if [[ -z "$span_id" ]]; then
        echo "ERROR: No span ID provided" >&2
        return 1
    fi
    
    local span_file="$SPAN_STATE_DIR/${span_id}.span"
    if [[ ! -f "$span_file" ]]; then
        echo "ERROR: Span file not found" >&2
        return 1
    fi
    
    # Update span status
    local temp_file="${span_file}.tmp"
    jq --arg status "$status" --arg desc "$description" \
        '.status = {code: $status, description: $desc}' \
        "$span_file" > "$temp_file" && mv "$temp_file" "$span_file"
}

# Export spans for processing
export_spans() {
    local output_format="${1:-json}"
    local output_file="${2:-/dev/stdout}"
    
    case "$output_format" in
        json)
            echo "[" > "$output_file"
            local first=true
            for span_file in "$SPAN_STATE_DIR"/*.span; do
                if [[ -f "$span_file" ]]; then
                    if [[ "$first" != "true" ]]; then
                        echo "," >> "$output_file"
                    fi
                    cat "$span_file" >> "$output_file"
                    first=false
                fi
            done
            echo "]" >> "$output_file"
            ;;
        otlp)
            # Convert to OTLP format (simplified)
            for span_file in "$SPAN_STATE_DIR"/*.span; do
                if [[ -f "$span_file" ]]; then
                    jq '{
                        resourceSpans: [{
                            resource: {
                                attributes: [
                                    {key: "service.name", value: {stringValue: "swarmsh"}},
                                    {key: "service.version", value: {stringValue: "2.0"}}
                                ]
                            },
                            scopeSpans: [{
                                scope: {name: "swarmsh.telemetry"},
                                spans: [.]
                            }]
                        }]
                    }' "$span_file" >> "$output_file"
                fi
            done
            ;;
        *)
            echo "ERROR: Unknown export format: $output_format" >&2
            return 1
            ;;
    esac
}

# Clean up old span files
cleanup_old_spans() {
    local max_age_seconds="${1:-3600}"  # Default: 1 hour
    
    find "$SPAN_STATE_DIR" -name "*.span" -type f -mtime +$((max_age_seconds / 86400)) -delete
}

# Span context propagation helpers
export_span_context() {
    local span_id="${1:-$CURRENT_SPAN_ID}"
    
    if [[ -z "$span_id" ]]; then
        echo "ERROR: No span ID to export" >&2
        return 1
    fi
    
    local span_file="$SPAN_STATE_DIR/${span_id}.span"
    if [[ ! -f "$span_file" ]]; then
        echo "ERROR: Span file not found" >&2
        return 1
    fi
    
    local trace_id=$(jq -r '.trace_id' "$span_file")
    echo "TRACE_ID=$trace_id SPAN_ID=$span_id"
}

import_span_context() {
    local context="$1"
    
    if [[ "$context" =~ TRACE_ID=([^ ]+)\ SPAN_ID=([^ ]+) ]]; then
        export TRACE_ID="${BASH_REMATCH[1]}"
        export PARENT_SPAN_ID="${BASH_REMATCH[2]}"
        echo "Imported span context: trace_id=$TRACE_ID parent_span_id=$PARENT_SPAN_ID"
    else
        echo "ERROR: Invalid span context format" >&2
        return 1
    fi
}