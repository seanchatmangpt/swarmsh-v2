#!/bin/bash
# Generated telemetry constants and helpers for SwarmSH v2 shell scripts
# 
# This code is generated by OTEL Weaver from semantic conventions.
# DO NOT EDIT MANUALLY.
#
# Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
# Generation timestamp: {{ params.generation_timestamp | default(now()) }}

# Enable strict error handling
set -euo pipefail

# SwarmSH Telemetry Constants
# ===========================

# Attribute Constants
{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
# {{ group.brief }}
      {% for attr in group.attributes %}
export {{ attr.id | replace(".", "_") | screaming_snake_case }}="{{ attr.id }}"
      {% endfor %}

    {% endfor %}
  {% endif %}
{% endfor %}

# Metric Names
{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
      {% if group.metrics %}
# {{ group.id }} Metrics
        {% for metric in group.metrics %}
export {{ metric.id | replace(".", "_") | screaming_snake_case }}_METRIC="{{ metric.id }}"
        {% endfor %}
      {% endif %}
    {% endfor %}
  {% endif %}
{% endfor %}

# Required Attributes by Domain
declare -A REQUIRED_ATTRIBUTES=(
{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
    ["{{ group.id }}"]="{{ group.attributes | selectattr("requirement_level", "eq", "required") | map(attribute="id") | join(" ") }}"
    {% endfor %}
  {% endif %}
{% endfor %}
)

# Recommended Attributes by Domain
declare -A RECOMMENDED_ATTRIBUTES=(
{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
    ["{{ group.id }}"]="{{ group.attributes | selectattr("requirement_level", "eq", "recommended") | map(attribute="id") | join(" ") }}"
    {% endfor %}
  {% endif %}
{% endfor %}
)

# Attribute Types
declare -A ATTRIBUTE_TYPES=(
{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
      {% for attr in group.attributes %}
    ["{{ attr.id }}"]="{{ attr.type }}"
      {% endfor %}
    {% endfor %}
  {% endif %}
{% endfor %}
)

# Valid Attribute Values (for enum-like attributes)
declare -A VALID_VALUES=(
{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
      {% for attr in group.attributes %}
        {% if attr.examples and attr.type == "string" %}
    ["{{ attr.id }}"]="{{ attr.examples | join(" ") }}"
        {% endif %}
      {% endfor %}
    {% endfor %}
  {% endif %}
{% endfor %}
)

# Helper Functions
# ================

# Validate attribute value type
validate_attribute_type() {
    local attr_name="$1"
    local attr_value="$2"
    local expected_type="${ATTRIBUTE_TYPES[$attr_name]:-string}"
    
    case "$expected_type" in
        "int")
            if ! [[ "$attr_value" =~ ^-?[0-9]+$ ]]; then
                echo "ERROR: Attribute '$attr_name' expects integer, got '$attr_value'" >&2
                return 1
            fi
            ;;
        "double")
            if ! [[ "$attr_value" =~ ^-?[0-9]+\.?[0-9]*$ ]]; then
                echo "ERROR: Attribute '$attr_name' expects double, got '$attr_value'" >&2
                return 1
            fi
            ;;
        "boolean")
            if [[ "$attr_value" != "true" && "$attr_value" != "false" ]]; then
                echo "ERROR: Attribute '$attr_name' expects boolean, got '$attr_value'" >&2
                return 1
            fi
            ;;
        "string"|*)
            # String type - always valid
            ;;
    esac
    
    return 0
}

# Validate required attributes for a domain
validate_required_attributes() {
    local domain="$1"
    shift
    local -A provided_attrs
    
    # Parse provided attributes
    while [[ $# -gt 0 ]]; do
        if [[ "$1" =~ ^([^=]+)=(.*)$ ]]; then
            provided_attrs["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]}"
        fi
        shift
    done
    
    # Check required attributes
    local required="${REQUIRED_ATTRIBUTES[$domain]:-}"
    for attr in $required; do
        if [[ -z "${provided_attrs[$attr]:-}" ]]; then
            echo "ERROR: Missing required attribute '$attr' for domain '$domain'" >&2
            return 1
        fi
    done
    
    return 0
}

# Get nanosecond timestamp
get_nano_timestamp() {
    if command -v gdate >/dev/null 2>&1; then
        # macOS with GNU date
        gdate +%s%N
    elif date --version >/dev/null 2>&1; then
        # Linux with GNU date
        date +%s%N
    else
        # Fallback: microsecond precision
        echo "$(date +%s)$(printf '%06d' $((RANDOM % 1000000)))"
    fi
}

# Format attributes for logging
format_attributes() {
    local result=""
    local first=true
    
    while [[ $# -gt 0 ]]; do
        if [[ "$1" =~ ^([^=]+)=(.*)$ ]]; then
            if [[ "$first" == "true" ]]; then
                first=false
            else
                result+=", "
            fi
            result+="${BASH_REMATCH[1]}=\"${BASH_REMATCH[2]}\""
        fi
        shift
    done
    
    echo "$result"
}

# Record a span (simplified for shell)
record_span() {
    local span_name="$1"
    local domain="$2"
    shift 2
    
    local start_time=$(get_nano_timestamp)
    local span_id=$(printf '%016x' $RANDOM$RANDOM)
    local trace_id=$(printf '%032x' $RANDOM$RANDOM$RANDOM$RANDOM)
    
    # Validate required attributes
    if ! validate_required_attributes "$domain" "$@"; then
        return 1
    fi
    
    # Log span start
    echo "[SPAN_START] name=$span_name, domain=$domain, trace_id=$trace_id, span_id=$span_id, start_time=$start_time, attributes={$(format_attributes "$@")}"
    
    # Return span context for span_end
    echo "$trace_id:$span_id:$start_time"
}

# End a span
span_end() {
    local span_context="$1"
    local status="${2:-OK}"
    
    if [[ "$span_context" =~ ^([^:]+):([^:]+):([^:]+)$ ]]; then
        local trace_id="${BASH_REMATCH[1]}"
        local span_id="${BASH_REMATCH[2]}"
        local start_time="${BASH_REMATCH[3]}"
        local end_time=$(get_nano_timestamp)
        local duration=$((end_time - start_time))
        
        echo "[SPAN_END] trace_id=$trace_id, span_id=$span_id, duration_ns=$duration, status=$status"
    else
        echo "ERROR: Invalid span context" >&2
        return 1
    fi
}

# Record a metric
record_metric() {
    local metric_name="$1"
    local metric_type="$2"
    local value="$3"
    shift 3
    
    local timestamp=$(get_nano_timestamp)
    
    case "$metric_type" in
        "counter"|"gauge"|"histogram")
            echo "[METRIC] name=$metric_name, type=$metric_type, value=$value, timestamp=$timestamp, labels={$(format_attributes "$@")}"
            ;;
        *)
            echo "ERROR: Unknown metric type '$metric_type'" >&2
            return 1
            ;;
    esac
}

# Record an event
record_event() {
    local event_name="$1"
    local severity="${2:-INFO}"
    local message="$3"
    shift 3
    
    local timestamp=$(get_nano_timestamp)
    
    echo "[EVENT] name=$event_name, severity=$severity, timestamp=$timestamp, message=\"$message\", attributes={$(format_attributes "$@")}"
}

# Export telemetry data to file (for batch processing)
export_telemetry_to_file() {
    local output_file="${1:-/tmp/swarmsh_telemetry_$(date +%Y%m%d_%H%M%S).log}"
    
    # Ensure directory exists
    mkdir -p "$(dirname "$output_file")"
    
    # Export function that appends to file
    export -f record_span_to_file
    export -f record_metric_to_file
    export -f record_event_to_file
    export TELEMETRY_OUTPUT_FILE="$output_file"
    
    echo "Telemetry export enabled to: $output_file"
}

# Versions for file export
record_span_to_file() {
    record_span "$@" >> "${TELEMETRY_OUTPUT_FILE:-/dev/stdout}"
}

record_metric_to_file() {
    record_metric "$@" >> "${TELEMETRY_OUTPUT_FILE:-/dev/stdout}"
}

record_event_to_file() {
    record_event "$@" >> "${TELEMETRY_OUTPUT_FILE:-/dev/stdout}"
}

# SwarmSH-specific helpers
# ========================

# Record worktree operation
record_worktree_operation() {
    local operation="$1"
    local worktree_name="$2"
    local worktree_path="$3"
    local branch="$4"
    shift 4
    
    local span_ctx=$(record_span "worktree.$operation" "swarmsh.worktree" \
        "${SWARMSH_WORKTREE_NAME}=$worktree_name" \
        "${SWARMSH_WORKTREE_PATH}=$worktree_path" \
        "${SWARMSH_WORKTREE_BRANCH}=$branch" \
        "${SWARMSH_WORKTREE_OPERATION}=$operation" \
        "$@")
    
    echo "$span_ctx"
}

# Record agent coordination
record_agent_coordination() {
    local agent_id="$1"
    local coordination_type="$2"
    shift 2
    
    local span_ctx=$(record_span "agent.coordination" "swarmsh.agent" \
        "${SWARMSH_AGENT_ID}=$agent_id" \
        "${SWARMSH_COORDINATION_TYPE}=$coordination_type" \
        "$@")
    
    echo "$span_ctx"
}

# Record work assignment
record_work_assignment() {
    local work_id="$1"
    local agent_id="$2"
    local priority="${3:-normal}"
    shift 3
    
    record_event "work.assigned" "INFO" "Work $work_id assigned to agent $agent_id" \
        "${SWARMSH_WORK_ID}=$work_id" \
        "${SWARMSH_WORK_ASSIGNED_AGENT}=$agent_id" \
        "${SWARMSH_WORK_PRIORITY}=$priority" \
        "$@"
}

# Initialize telemetry subsystem
init_telemetry() {
    local service_name="${1:-swarmsh}"
    local service_version="${2:-unknown}"
    
    export TELEMETRY_SERVICE_NAME="$service_name"
    export TELEMETRY_SERVICE_VERSION="$service_version"
    export TELEMETRY_INITIALIZED="true"
    
    record_event "telemetry.initialized" "INFO" "Telemetry subsystem initialized" \
        "service.name=$service_name" \
        "service.version=$service_version"
}

# Shutdown telemetry subsystem
shutdown_telemetry() {
    if [[ "${TELEMETRY_INITIALIZED:-false}" == "true" ]]; then
        record_event "telemetry.shutdown" "INFO" "Telemetry subsystem shutting down"
        export TELEMETRY_INITIALIZED="false"
    fi
}

# Auto-initialize if SERVICE_NAME is set
if [[ -n "${SERVICE_NAME:-}" ]]; then
    init_telemetry "$SERVICE_NAME" "${SERVICE_VERSION:-unknown}"
fi