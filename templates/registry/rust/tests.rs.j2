//! Generated tests for SwarmSH v2 telemetry
//! 
//! This code is generated by OTEL Weaver from semantic conventions.
//! DO NOT EDIT MANUALLY.
//!
//! Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
//! Generation timestamp: {{ params.generation_timestamp | default(now()) }}

#[cfg(test)]
mod generated_tests {
    use super::*;
    use std::collections::HashMap;
    use std::time::Duration;
    use tracing::Level;
    use tracing_test::traced_test;

    {% for convention in ctx %}
      {% if convention.groups %}
        {% for group in convention.groups %}
    mod {{ group.id | replace(".", "_") | snake_case }}_tests {
        use super::*;
        use crate::generated::attributes::{{ group.id | replace(".", "_") | snake_case }}::*;
        use crate::generated::span_builders::*;
        use crate::generated::metrics::*;
        use crate::telemetry::validation::*;

        #[test]
        fn test_{{ group.id | replace(".", "_") | snake_case }}_attributes() {
            // Test all attribute constants are properly defined
            {% for attr in group.attributes %}
            assert_eq!({{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | screaming_snake_case }}, "{{ attr.id }}");
            {% endfor %}
            
            // Test attribute lists
            let all_attrs = all_attributes();
            assert_eq!(all_attrs.len(), {{ group.attributes | length }});
            
            let required_attrs = required_attributes();
            assert_eq!(required_attrs.len(), {{ group.attributes | selectattr("requirement_level", "eq", "required") | list | length }});
            
            let recommended_attrs = recommended_attributes();
            assert_eq!(recommended_attrs.len(), {{ group.attributes | selectattr("requirement_level", "eq", "recommended") | list | length }});
        }

        #[test]
        fn test_{{ group.id | replace(".", "_") | snake_case }}_attribute_metadata() {
            let metadata = metadata();
            
            {% for attr in group.attributes %}
            // Test {{ attr.id }} metadata
            {
                let attr_meta = metadata.get({{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | screaming_snake_case }}).unwrap();
                assert_eq!(attr_meta.id, "{{ attr.id }}");
                assert_eq!(attr_meta.brief, "{{ attr.brief }}");
                {% if attr.note %}
                assert_eq!(attr_meta.note, Some("{{ attr.note | escape }}".to_string()));
                {% else %}
                assert_eq!(attr_meta.note, None);
                {% endif %}
                assert_eq!(attr_meta.requirement_level, {% if attr.requirement_level == "required" %}RequirementLevel::Required{% elif attr.requirement_level == "recommended" %}RequirementLevel::Recommended{% else %}RequirementLevel::OptIn{% endif %});
            }
            {% endfor %}
        }

          {% if group.type == "span" %}
        #[traced_test]
        #[test]
        fn test_{{ group.id | replace(".", "_") | snake_case }}_span_builder() {
            // Test span builder with all required attributes
            let builder = {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder::new("test_operation")
                {% for attr in group.attributes %}
                  {% if attr.requirement_level == "required" %}
                    {% if attr.type == "string" %}
                .with_{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}("{{ attr.examples[0] | default("test_value") }}")
                    {% elif attr.type == "int" %}
                .with_{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}({{ attr.examples[0] | default(42) }})
                    {% elif attr.type == "double" %}
                .with_{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}({{ attr.examples[0] | default(3.14) }})
                    {% elif attr.type == "boolean" %}
                .with_{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}(true)
                    {% endif %}
                  {% endif %}
                {% endfor %}
                ;

            assert!(builder.is_valid());
            
            // Test building the span
            let span = builder.build_tracing();
            assert!(span.is_ok());
        }

        #[test]
        fn test_{{ group.id | replace(".", "_") | snake_case }}_span_builder_validation() {
            // Test validation with missing required attributes
            let mut builder = {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder::new("test_operation");
            
            let validation_result = builder.validate();
            {% if group.attributes | selectattr("requirement_level", "eq", "required") | list | length > 0 %}
            assert!(validation_result.is_err());
            {% else %}
            assert!(validation_result.is_ok());
            {% endif %}
            
            // Test with optional enforcement disabled
            let builder_no_enforce = {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder::new("test_operation")
                .without_required_enforcement();
            assert!(builder_no_enforce.is_valid());
        }
          {% endif %}

        #[test]
        fn test_{{ group.id | replace(".", "_") | snake_case }}_attribute_validation() {
            let mut attributes = HashMap::new();
            
            // Add all required attributes with valid values
            {% for attr in group.attributes %}
              {% if attr.requirement_level == "required" %}
                {% if attr.type == "string" %}
            attributes.insert("{{ attr.id }}".to_string(), "{{ attr.examples[0] | default("valid_value") }}".to_string());
                {% elif attr.type == "int" %}
            attributes.insert("{{ attr.id }}".to_string(), "{{ attr.examples[0] | default(42) }}".to_string());
                {% elif attr.type == "double" %}
            attributes.insert("{{ attr.id }}".to_string(), "{{ attr.examples[0] | default(3.14) }}".to_string());
                {% elif attr.type == "boolean" %}
            attributes.insert("{{ attr.id }}".to_string(), "true".to_string());
                {% endif %}
              {% endif %}
            {% endfor %}
            
            // Validate with strict mode
            let result = validate_attributes("{{ group.id }}", &attributes, true);
            assert!(result.is_valid());
            
            // Test with invalid attribute type
            {% for attr in group.attributes %}
              {% if attr.type == "int" %}
            attributes.insert("{{ attr.id }}".to_string(), "not_a_number".to_string());
            let invalid_result = validate_attributes("{{ group.id }}", &attributes, true);
            assert!(!invalid_result.is_valid());
            attributes.insert("{{ attr.id }}".to_string(), "123".to_string()); // restore valid value
                {% break %}
              {% endif %}
            {% endfor %}
        }

          {% if group.metrics %}
        #[test]
        fn test_{{ group.id | replace(".", "_") | snake_case }}_metrics() {
            let metrics = {{ group.id | replace(".", "_") | pascal_case }}Metrics::new();
            
            // Test metric recording
            {% for metric in group.metrics %}
              {% if metric.instrument == "counter" %}
            metrics.record_{{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}(1, &[("test_label", "test_value")]);
              {% elif metric.instrument == "gauge" %}
            metrics.record_{{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}(42.0, &[("test_label", "test_value")]);
              {% elif metric.instrument == "histogram" %}
            metrics.record_{{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}(100.5, &[("test_label", "test_value")]);
              {% endif %}
            {% endfor %}
            
            // Test metadata
            let metadata = {{ group.id | replace(".", "_") | pascal_case }}Metrics::metadata();
            assert_eq!(metadata.len(), {{ group.metrics | length }});
        }
          {% endif %}

          {% if group.events %}
        #[traced_test]
        #[test]
        fn test_{{ group.id | replace(".", "_") | snake_case }}_events() {
            {% for event in group.events %}
            // Test {{ event.id }} event
            {
                let event = {{ group.id | replace(".", "_") | snake_case }}_events::{{ event.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}("Test event message");
                assert_eq!(event.name, "{{ event.id }}");
                assert_eq!(event.severity, EventSeverity::{{ event.severity | default("Info") | capitalize }});
                
                // Record the event
                event.record_tracing();
            }
            {% endfor %}
        }
          {% endif %}

        #[test]
        fn test_{{ group.id | replace(".", "_") | snake_case }}_performance() {
            use std::time::Instant;
            
            // Benchmark attribute access
            let start = Instant::now();
            for _ in 0..10000 {
                let _ = all_attributes();
            }
            let duration = start.elapsed();
            assert!(duration < Duration::from_millis(100), "Attribute access too slow: {:?}", duration);
            
            // Benchmark validation
            let mut attributes = HashMap::new();
            {% for attr in group.attributes | slice(0, 3) %}
              {% if attr.type == "string" %}
            attributes.insert("{{ attr.id }}".to_string(), "test_value".to_string());
              {% endif %}
            {% endfor %}
            
            let start = Instant::now();
            for _ in 0..1000 {
                let _ = validate_attributes("{{ group.id }}", &attributes, false);
            }
            let duration = start.elapsed();
            assert!(duration < Duration::from_millis(100), "Validation too slow: {:?}", duration);
        }

        #[test]
        fn test_{{ group.id | replace(".", "_") | snake_case }}_edge_cases() {
            // Test empty attribute values
            let mut attributes = HashMap::new();
            attributes.insert("{{ group.attributes[0].id }}".to_string(), "".to_string());
            
            let result = validate_attributes("{{ group.id }}", &attributes, true);
            // Empty strings are generally valid unless there's a min_length constraint
            
            // Test very long attribute values
            let long_value = "x".repeat(10000);
            attributes.insert("{{ group.attributes[0].id }}".to_string(), long_value);
            
            let result = validate_attributes("{{ group.id }}", &attributes, false);
            // Should handle long values gracefully
            
            // Test special characters in values
            let special_chars = "!@#$%^&*()[]{}|\\<>?,./:;'\"~`";
            attributes.insert("{{ group.attributes[0].id }}".to_string(), special_chars.to_string());
            
            let result = validate_attributes("{{ group.id }}", &attributes, false);
            // Should handle special characters
        }
    }

        {% endfor %}
      {% endif %}
    {% endfor %}

    /// Integration tests for the entire generated telemetry system
    mod integration_tests {
        use super::*;
        use crate::generated::*;
        use std::sync::Arc;
        use tokio::sync::RwLock;

        #[tokio::test]
        async fn test_full_telemetry_lifecycle() {
            // Initialize metrics registry
            let metrics = MetricsRegistry::new();
            
            // Create spans for different operations
            {% for convention in ctx %}
              {% if convention.groups %}
                {% for group in convention.groups %}
                  {% if group.type == "span" %}
            {
                let span = {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder::new("integration_test")
                    {% set required_attrs = group.attributes | selectattr("requirement_level", "eq", "required") | list %}
                    {% for attr in required_attrs | slice(0, 2) %}
                      {% if attr.type == "string" %}
                    .with_{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") }}("test_{{ loop.index }}")
                      {% endif %}
                    {% endfor %}
                    .build_tracing()
                    .expect("Failed to build span");
                
                let _guard = span.enter();
                // Simulate some work
                tokio::time::sleep(Duration::from_millis(10)).await;
            }
                  {% endif %}
                {% endfor %}
              {% endif %}
            {% endfor %}
            
            // Record some metrics
            {% for convention in ctx %}
              {% if convention.groups %}
                {% for group in convention.groups %}
                  {% if group.metrics %}
                    {% for metric in group.metrics | slice(0, 2) %}
            metrics.{{ group.id | replace(".", "_") | snake_case }}.record_{{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}(
                      {% if metric.instrument == "counter" %}1{% else %}42.0{% endif %},
                &[("test", "integration")]
            );
                    {% endfor %}
                  {% endif %}
                {% endfor %}
              {% endif %}
            {% endfor %}
        }

        #[test]
        fn test_cross_domain_validation() {
            // Test that attributes from different domains don't interfere
            let mut agent_attrs = HashMap::new();
            let mut work_attrs = HashMap::new();
            
            // Add some attributes to each
            agent_attrs.insert("swarmsh.agent.id".to_string(), "agent_123".to_string());
            work_attrs.insert("swarmsh.work.id".to_string(), "work_456".to_string());
            
            // Validate separately
            let agent_result = validate_attributes("swarmsh.agent", &agent_attrs, false);
            let work_result = validate_attributes("swarmsh.work", &work_attrs, false);
            
            // Both should be valid in their respective contexts
            assert!(agent_result.warnings.is_empty() || agent_result.errors.is_empty());
            assert!(work_result.warnings.is_empty() || work_result.errors.is_empty());
        }

        #[test]
        fn test_attribute_registry_completeness() {
            let registry = &*ATTRIBUTE_REGISTRY;
            
            // Check that all semantic convention attributes are in the registry
            let expected_count = 0
                {% for convention in ctx %}
                  {% if convention.groups %}
                    {% for group in convention.groups %}
                + {{ group.attributes | length }}
                    {% endfor %}
                  {% endif %}
                {% endfor %}
                ;
            
            assert!(
                registry.len() >= expected_count / 2, // Allow for some filtering
                "Registry has {} attributes, expected at least {}",
                registry.len(),
                expected_count / 2
            );
        }
    }

    /// Benchmarks for generated code
    #[cfg(all(test, not(debug_assertions)))]
    mod benchmarks {
        use super::*;
        use criterion::{black_box, Criterion};

        pub fn bench_span_creation(c: &mut Criterion) {
            c.bench_function("span_creation", |b| {
                b.iter(|| {
                    {% for convention in ctx %}
                      {% if convention.groups %}
                        {% for group in convention.groups %}
                          {% if group.type == "span" %}
                    let span = {{ group.id | replace(".", "_") | pascal_case }}SpanBuilder::new("bench")
                        .build_tracing()
                        .unwrap();
                    black_box(span);
                            {% break %}
                          {% endif %}
                        {% endfor %}
                      {% endif %}
                    {% endfor %}
                });
            });
        }

        pub fn bench_attribute_validation(c: &mut Criterion) {
            let mut attributes = HashMap::new();
            attributes.insert("test.attr".to_string(), "value".to_string());
            
            c.bench_function("attribute_validation", |b| {
                b.iter(|| {
                    let result = validate_attributes("test.domain", &attributes, false);
                    black_box(result);
                });
            });
        }
    }
}