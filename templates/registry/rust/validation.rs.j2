//! Generated attribute validation for SwarmSH v2 telemetry
//! 
//! This code is generated by OTEL Weaver from semantic conventions.
//! DO NOT EDIT MANUALLY.
//!
//! Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
//! Generation timestamp: {{ params.generation_timestamp | default(now()) }}

use lazy_static::lazy_static;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fmt;

use crate::telemetry::errors::TelemetryError;

/// Validation result containing errors and warnings
#[derive(Debug, Default, Clone)]
pub struct ValidationResult {
    pub errors: Vec<ValidationError>,
    pub warnings: Vec<ValidationWarning>,
}

impl ValidationResult {
    /// Check if validation passed (no errors)
    pub fn is_valid(&self) -> bool {
        self.errors.is_empty()
    }

    /// Add an error
    pub fn add_error(&mut self, error: ValidationError) {
        self.errors.push(error);
    }

    /// Add a warning
    pub fn add_warning(&mut self, warning: ValidationWarning) {
        self.warnings.push(warning);
    }

    /// Convert to Result type
    pub fn to_result(self) -> Result<(), TelemetryError> {
        if self.is_valid() {
            Ok(())
        } else {
            Err(TelemetryError::ValidationError(
                self.errors.iter()
                    .map(|e| e.to_string())
                    .collect::<Vec<_>>()
                    .join("; ")
            ))
        }
    }
}

/// Validation error types
#[derive(Debug, Clone, PartialEq)]
pub enum ValidationError {
    MissingRequiredAttribute { attribute: String },
    InvalidAttributeType { attribute: String, expected: String, actual: String },
    InvalidAttributeValue { attribute: String, value: String, reason: String },
    InvalidAttributeName { name: String, reason: String },
    DuplicateAttribute { attribute: String },
    UnknownAttribute { attribute: String },
}

impl fmt::Display for ValidationError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::MissingRequiredAttribute { attribute } => {
                write!(f, "Missing required attribute: {}", attribute)
            }
            Self::InvalidAttributeType { attribute, expected, actual } => {
                write!(f, "Invalid type for attribute '{}': expected {}, got {}", attribute, expected, actual)
            }
            Self::InvalidAttributeValue { attribute, value, reason } => {
                write!(f, "Invalid value '{}' for attribute '{}': {}", value, attribute, reason)
            }
            Self::InvalidAttributeName { name, reason } => {
                write!(f, "Invalid attribute name '{}': {}", name, reason)
            }
            Self::DuplicateAttribute { attribute } => {
                write!(f, "Duplicate attribute: {}", attribute)
            }
            Self::UnknownAttribute { attribute } => {
                write!(f, "Unknown attribute: {} (not defined in semantic conventions)", attribute)
            }
        }
    }
}

/// Validation warning types
#[derive(Debug, Clone, PartialEq)]
pub enum ValidationWarning {
    DeprecatedAttribute { attribute: String, message: String },
    NonRecommendedValue { attribute: String, value: String, recommended: Vec<String> },
    MissingRecommendedAttribute { attribute: String },
    PerformanceWarning { message: String },
}

impl fmt::Display for ValidationWarning {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::DeprecatedAttribute { attribute, message } => {
                write!(f, "Deprecated attribute '{}': {}", attribute, message)
            }
            Self::NonRecommendedValue { attribute, value, recommended } => {
                write!(f, "Non-recommended value '{}' for attribute '{}'. Recommended: {:?}", value, attribute, recommended)
            }
            Self::MissingRecommendedAttribute { attribute } => {
                write!(f, "Missing recommended attribute: {}", attribute)
            }
            Self::PerformanceWarning { message } => {
                write!(f, "Performance warning: {}", message)
            }
        }
    }
}

/// Attribute value constraints
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttributeConstraints {
    pub pattern: Option<String>,
    pub min_value: Option<f64>,
    pub max_value: Option<f64>,
    pub min_length: Option<usize>,
    pub max_length: Option<usize>,
    pub allowed_values: Option<Vec<String>>,
}

lazy_static! {
    /// Compiled regex patterns for attribute validation
    static ref VALIDATION_PATTERNS: HashMap<String, Regex> = {
        let mut patterns = HashMap::new();
        
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% for attr in group.attributes %}
                {% if attr.pattern %}
        patterns.insert(
            "{{ attr.id }}".to_string(),
            Regex::new(r"{{ attr.pattern }}").unwrap()
        );
                {% endif %}
              {% endfor %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        
        // Common patterns
        patterns.insert(
            "_identifier".to_string(),
            Regex::new(r"^[a-zA-Z][a-zA-Z0-9_-]*$").unwrap()
        );
        patterns.insert(
            "_uuid".to_string(),
            Regex::new(r"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$").unwrap()
        );
        patterns.insert(
            "_semver".to_string(),
            Regex::new(r"^\d+\.\d+\.\d+(-[a-zA-Z0-9-]+)?(\+[a-zA-Z0-9-]+)?$").unwrap()
        );
        
        patterns
    };

    /// Attribute constraints from semantic conventions
    static ref ATTRIBUTE_CONSTRAINTS: HashMap<String, AttributeConstraints> = {
        let mut constraints = HashMap::new();
        
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% for attr in group.attributes %}
                {% if attr.pattern or attr.min_value or attr.max_value or attr.min_length or attr.max_length or attr.allowed_values %}
        constraints.insert(
            "{{ attr.id }}".to_string(),
            AttributeConstraints {
                pattern: {% if attr.pattern %}Some("{{ attr.pattern }}".to_string()){% else %}None{% endif %},
                min_value: {% if attr.min_value %}Some({{ attr.min_value }}){% else %}None{% endif %},
                max_value: {% if attr.max_value %}Some({{ attr.max_value }}){% else %}None{% endif %},
                min_length: {% if attr.min_length %}Some({{ attr.min_length }}){% else %}None{% endif %},
                max_length: {% if attr.max_length %}Some({{ attr.max_length }}){% else %}None{% endif %},
                allowed_values: {% if attr.allowed_values %}Some(vec![{{ attr.allowed_values | map('quote') | join(", ") }}]){% elif attr.examples and attr.type == "string" and attr.requirement_level == "required" %}Some(vec![{{ attr.examples | map('quote') | join(", ") }}]){% else %}None{% endif %},
            }
        );
                {% endif %}
              {% endfor %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        
        constraints
    };
}

/// Validate attributes for a specific semantic convention group
pub fn validate_attributes(
    group_id: &str,
    attributes: &HashMap<String, String>,
    strict_mode: bool,
) -> ValidationResult {
    let mut result = ValidationResult::default();
    let mut seen_attributes = HashSet::new();

    // Check for duplicates
    for (key, _) in attributes {
        if !seen_attributes.insert(key.clone()) {
            result.add_error(ValidationError::DuplicateAttribute {
                attribute: key.clone(),
            });
        }
    }

    // Validate based on semantic convention group
    match group_id {
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
        "{{ group.id }}" => {
            validate_{{ group.id | replace(".", "_") | snake_case }}_attributes(attributes, strict_mode, &mut result);
        }
            {% endfor %}
          {% endif %}
        {% endfor %}
        _ => {
            // Unknown group - validate generically
            for (key, value) in attributes {
                validate_generic_attribute(key, value, strict_mode, &mut result);
            }
        }
    }

    result
}

{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
/// Validate attributes for {{ group.id }}
fn validate_{{ group.id | replace(".", "_") | snake_case }}_attributes(
    attributes: &HashMap<String, String>,
    strict_mode: bool,
    result: &mut ValidationResult,
) {
    // Check required attributes
      {% for attr in group.attributes %}
        {% if attr.requirement_level == "required" %}
    if !attributes.contains_key("{{ attr.id }}") {
        result.add_error(ValidationError::MissingRequiredAttribute {
            attribute: "{{ attr.id }}".to_string(),
        });
    }
        {% endif %}
      {% endfor %}

    // Check recommended attributes
      {% for attr in group.attributes %}
        {% if attr.requirement_level == "recommended" %}
    if !attributes.contains_key("{{ attr.id }}") && strict_mode {
        result.add_warning(ValidationWarning::MissingRecommendedAttribute {
            attribute: "{{ attr.id }}".to_string(),
        });
    }
        {% endif %}
      {% endfor %}

    // Validate each attribute
    for (key, value) in attributes {
        match key.as_str() {
            {% for attr in group.attributes %}
            "{{ attr.id }}" => {
                validate_{{ attr.type | rust_validation_fn }}(key, value, result);
                {% if attr.deprecated %}
                result.add_warning(ValidationWarning::DeprecatedAttribute {
                    attribute: key.clone(),
                    message: "{{ attr.deprecated }}".to_string(),
                });
                {% endif %}
                {% if attr.pattern or attr.allowed_values or attr.min_value or attr.max_value %}
                if let Some(constraints) = ATTRIBUTE_CONSTRAINTS.get(key) {
                    validate_constraints(key, value, constraints, result);
                }
                {% endif %}
            }
            {% endfor %}
            _ => {
                if strict_mode {
                    result.add_error(ValidationError::UnknownAttribute {
                        attribute: key.clone(),
                    });
                }
            }
        }
    }
}

    {% endfor %}
  {% endif %}
{% endfor %}

/// Generic attribute validation
fn validate_generic_attribute(
    key: &str,
    value: &str,
    strict_mode: bool,
    result: &mut ValidationResult,
) {
    // Validate attribute name format
    if !key.chars().all(|c| c.is_alphanumeric() || c == '.' || c == '_') {
        result.add_error(ValidationError::InvalidAttributeName {
            name: key.to_string(),
            reason: "Attribute names must contain only alphanumeric characters, dots, and underscores".to_string(),
        });
    }

    // Check if it matches any known constraints
    if let Some(constraints) = ATTRIBUTE_CONSTRAINTS.get(key) {
        validate_constraints(key, value, constraints, result);
    }
}

/// Validate value against constraints
fn validate_constraints(
    key: &str,
    value: &str,
    constraints: &AttributeConstraints,
    result: &mut ValidationResult,
) {
    // Pattern validation
    if let Some(pattern_key) = &constraints.pattern {
        if let Some(regex) = VALIDATION_PATTERNS.get(pattern_key).or_else(|| VALIDATION_PATTERNS.get(key)) {
            if !regex.is_match(value) {
                result.add_error(ValidationError::InvalidAttributeValue {
                    attribute: key.to_string(),
                    value: value.to_string(),
                    reason: format!("Does not match pattern: {}", pattern_key),
                });
            }
        }
    }

    // Allowed values validation
    if let Some(allowed) = &constraints.allowed_values {
        if !allowed.contains(&value.to_string()) {
            result.add_warning(ValidationWarning::NonRecommendedValue {
                attribute: key.to_string(),
                value: value.to_string(),
                recommended: allowed.clone(),
            });
        }
    }

    // Length validation for strings
    if let Some(min_len) = constraints.min_length {
        if value.len() < min_len {
            result.add_error(ValidationError::InvalidAttributeValue {
                attribute: key.to_string(),
                value: value.to_string(),
                reason: format!("Too short (minimum {} characters)", min_len),
            });
        }
    }

    if let Some(max_len) = constraints.max_length {
        if value.len() > max_len {
            result.add_error(ValidationError::InvalidAttributeValue {
                attribute: key.to_string(),
                value: value.to_string(),
                reason: format!("Too long (maximum {} characters)", max_len),
            });
        }
    }
}

// Type validation functions
fn validate_string(_key: &str, _value: &str, _result: &mut ValidationResult) {
    // String values are always valid
}

fn validate_int(key: &str, value: &str, result: &mut ValidationResult) {
    if value.parse::<i64>().is_err() {
        result.add_error(ValidationError::InvalidAttributeType {
            attribute: key.to_string(),
            expected: "integer".to_string(),
            actual: "string".to_string(),
        });
    }
}

fn validate_double(key: &str, value: &str, result: &mut ValidationResult) {
    if value.parse::<f64>().is_err() {
        result.add_error(ValidationError::InvalidAttributeType {
            attribute: key.to_string(),
            expected: "double".to_string(),
            actual: "string".to_string(),
        });
    }
}

fn validate_boolean(key: &str, value: &str, result: &mut ValidationResult) {
    if !["true", "false"].contains(&value) {
        result.add_error(ValidationError::InvalidAttributeType {
            attribute: key.to_string(),
            expected: "boolean".to_string(),
            actual: "string".to_string(),
        });
    }
}

fn validate_string_array(key: &str, value: &str, result: &mut ValidationResult) {
    // For validation purposes, we expect a comma-separated list
    if value.is_empty() {
        result.add_error(ValidationError::InvalidAttributeValue {
            attribute: key.to_string(),
            value: value.to_string(),
            reason: "Array cannot be empty".to_string(),
        });
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validation_required_attributes() {
        let mut attributes = HashMap::new();
        
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% if group.attributes | selectattr("requirement_level", "eq", "required") | list | length > 0 %}
        // Test {{ group.id }} without required attributes
        let result = validate_attributes("{{ group.id }}", &attributes, false);
        assert!(!result.is_valid());
        assert_eq!(result.errors.len(), {{ group.attributes | selectattr("requirement_level", "eq", "required") | list | length }});
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
    }

    #[test]
    fn test_validation_patterns() {
        let mut attributes = HashMap::new();
        
        // Test identifier pattern
        attributes.insert("test.id".to_string(), "invalid-identifier!".to_string());
        
        if let Some(regex) = VALIDATION_PATTERNS.get("_identifier") {
            assert!(!regex.is_match("invalid-identifier!"));
            assert!(regex.is_match("valid_identifier123"));
        }
    }

    #[test]
    fn test_type_validation() {
        let mut result = ValidationResult::default();
        
        // Test integer validation
        validate_int("test", "123", &mut result);
        assert!(result.is_valid());
        
        validate_int("test", "not_a_number", &mut result);
        assert!(!result.is_valid());
    }
}