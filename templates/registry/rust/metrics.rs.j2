//! Generated metrics for SwarmSH v2 telemetry
//! 
//! This code is generated by OTEL Weaver from semantic conventions.
//! DO NOT EDIT MANUALLY.
//!
//! Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
//! Generation timestamp: {{ params.generation_timestamp | default(now()) }}

use metrics::{counter, gauge, histogram, Counter, Gauge, Histogram, Unit};
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::sync::Arc;

use crate::telemetry::errors::TelemetryError;

/// Metric metadata
#[derive(Debug, Clone)]
pub struct MetricMetadata {
    pub name: String,
    pub description: String,
    pub unit: Option<Unit>,
    pub instrument_type: InstrumentType,
    pub attributes: Vec<String>,
}

/// Instrument types for metrics
#[derive(Debug, Clone, PartialEq)]
pub enum InstrumentType {
    Counter,
    Gauge,
    Histogram,
    UpDownCounter,
}

{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
      {% if group.metrics %}
/// {{ group.brief }}
{% if group.note %}
///
{{ group.note | comment("rust") }}
{% endif %}
#[derive(Clone)]
pub struct {{ group.id | replace(".", "_") | pascal_case }}Metrics {
        {% for metric in group.metrics %}
    /// {{ metric.brief }}
          {% if metric.note %}
    {{ metric.note | comment("rust") | indent(4) }}
          {% endif %}
    pub {{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}: {{ metric.instrument | rust_metric_type }},
        {% endfor %}
}

impl {{ group.id | replace(".", "_") | pascal_case }}Metrics {
    /// Create a new instance of {{ group.id }} metrics
    pub fn new() -> Self {
        Self {
            {% for metric in group.metrics %}
            {{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}: {{ metric.instrument | rust_metric_init(metric) }},
            {% endfor %}
        }
    }

    /// Get metric metadata
    pub fn metadata() -> HashMap<String, MetricMetadata> {
        let mut map = HashMap::new();
        
        {% for metric in group.metrics %}
        map.insert(
            "{{ metric.id }}".to_string(),
            MetricMetadata {
                name: "{{ metric.id }}".to_string(),
                description: "{{ metric.brief }}".to_string(),
                unit: {% if metric.unit %}Some(Unit::{{ metric.unit | rust_unit }}){% else %}None{% endif %},
                instrument_type: InstrumentType::{{ metric.instrument | capitalize }},
                attributes: vec![
                    {% if metric.attributes %}
                      {% for attr in metric.attributes %}
                    "{{ attr }}".to_string(),
                      {% endfor %}
                    {% endif %}
                ],
            }
        );
        {% endfor %}
        
        map
    }

        {% for metric in group.metrics %}
    /// Record a value for {{ metric.id }}
          {% if metric.note %}
    ///
    {{ metric.note | comment("rust") | indent(4) }}
          {% endif %}
    pub fn record_{{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}(&self, value: {{ metric.instrument | rust_value_type }}, labels: &[(&str, &str)]) {
        {% if metric.instrument == "counter" %}
        self.{{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}.increment(value);
        {% elif metric.instrument == "gauge" %}
        self.{{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}.set(value);
        {% elif metric.instrument == "histogram" %}
        self.{{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}.record(value);
        {% elif metric.instrument == "updowncounter" %}
        self.{{ metric.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}.add(value);
        {% endif %}
    }

        {% endfor %}
}

impl Default for {{ group.id | replace(".", "_") | pascal_case }}Metrics {
    fn default() -> Self {
        Self::new()
    }
}

      {% endif %}
    {% endfor %}
  {% endif %}
{% endfor %}

/// Global metrics registry
pub struct MetricsRegistry {
    {% for convention in ctx %}
      {% if convention.groups %}
        {% for group in convention.groups %}
          {% if group.metrics %}
    pub {{ group.id | replace(".", "_") | snake_case }}: {{ group.id | replace(".", "_") | pascal_case }}Metrics,
          {% endif %}
        {% endfor %}
      {% endif %}
    {% endfor %}
}

impl MetricsRegistry {
    /// Create a new metrics registry with all metric groups
    pub fn new() -> Self {
        Self {
            {% for convention in ctx %}
              {% if convention.groups %}
                {% for group in convention.groups %}
                  {% if group.metrics %}
            {{ group.id | replace(".", "_") | snake_case }}: {{ group.id | replace(".", "_") | pascal_case }}Metrics::new(),
                  {% endif %}
                {% endfor %}
              {% endif %}
            {% endfor %}
        }
    }

    /// Get all metric metadata
    pub fn all_metadata() -> HashMap<String, MetricMetadata> {
        let mut all = HashMap::new();
        
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% if group.metrics %}
        all.extend({{ group.id | replace(".", "_") | pascal_case }}Metrics::metadata());
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
        
        all
    }
}

/// Global metrics instance
pub static METRICS: Lazy<MetricsRegistry> = Lazy::new(MetricsRegistry::new);

/// Helper macro to record metrics with labels
#[macro_export]
macro_rules! record_metric {
    ($metric:expr, $value:expr, $($label_key:expr => $label_value:expr),*) => {
        {
            let labels = vec![
                $(($label_key, $label_value),)*
            ];
            $metric.record($value, &labels);
        }
    };
}

/// Builder for recording metrics with attributes
pub struct MetricRecorder<'a> {
    metric_name: &'a str,
    value: f64,
    attributes: HashMap<String, String>,
}

impl<'a> MetricRecorder<'a> {
    /// Create a new metric recorder
    pub fn new(metric_name: &'a str, value: f64) -> Self {
        Self {
            metric_name,
            value,
            attributes: HashMap::new(),
        }
    }

    /// Add an attribute
    pub fn with_attribute(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.attributes.insert(key.into(), value.into());
        self
    }

    /// Record the metric
    pub fn record(self) -> Result<(), TelemetryError> {
        // In a real implementation, this would look up the metric by name
        // and record the value with attributes
        tracing::debug!(
            metric = self.metric_name,
            value = self.value,
            attributes = ?self.attributes,
            "Recording metric"
        );
        Ok(())
    }
}

/// Convenience functions for common metric operations
pub mod helpers {
    use super::*;
    use std::time::{Duration, Instant};

    /// Time a closure and record the duration as a histogram metric
    pub fn time_operation<F, R>(
        metric: &Histogram,
        operation: F,
    ) -> Result<R, TelemetryError>
    where
        F: FnOnce() -> Result<R, TelemetryError>,
    {
        let start = Instant::now();
        let result = operation();
        let duration = start.elapsed();
        
        metric.record(duration.as_millis() as f64);
        
        result
    }

    /// Increment a counter when entering a scope, decrement when leaving
    pub struct ScopedGauge<'a> {
        gauge: &'a Gauge,
        decremented: bool,
    }

    impl<'a> ScopedGauge<'a> {
        pub fn new(gauge: &'a Gauge) -> Self {
            gauge.increment(1.0);
            Self {
                gauge,
                decremented: false,
            }
        }
    }

    impl<'a> Drop for ScopedGauge<'a> {
        fn drop(&mut self) {
            if !self.decremented {
                self.gauge.decrement(1.0);
                self.decremented = true;
            }
        }
    }

    /// Record the size of a collection
    pub fn record_collection_size<T>(gauge: &Gauge, collection: &[T]) {
        gauge.set(collection.len() as f64);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_metrics_creation() {
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% if group.metrics %}
        let metrics = {{ group.id | replace(".", "_") | pascal_case }}Metrics::new();
        // Metrics should be created without panic
        let _ = &metrics;
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
    }

    #[test]
    fn test_metrics_registry() {
        let registry = MetricsRegistry::new();
        let metadata = MetricsRegistry::all_metadata();
        
        // Should have metadata for all metrics
        assert!(!metadata.is_empty());
    }

    #[test]
    fn test_metric_recorder() {
        let recorder = MetricRecorder::new("test.metric", 42.0)
            .with_attribute("environment", "test")
            .with_attribute("version", "1.0.0");
        
        assert!(recorder.record().is_ok());
    }

    #[test]
    fn test_time_operation() {
        use metrics::histogram;
        let hist = histogram!("test_duration");
        
        let result = helpers::time_operation(&hist, || {
            std::thread::sleep(Duration::from_millis(10));
            Ok::<_, TelemetryError>(42)
        });
        
        assert_eq!(result.unwrap(), 42);
    }
}

// Extension trait for metric types
pub trait MetricExt {
    /// Record a value with labels
    fn record_with_labels(&self, value: f64, labels: &[(&str, &str)]);
}

impl MetricExt for Counter {
    fn record_with_labels(&self, value: f64, labels: &[(&str, &str)]) {
        // In a real implementation, this would apply labels
        self.increment(value as u64);
    }
}

impl MetricExt for Gauge {
    fn record_with_labels(&self, value: f64, labels: &[(&str, &str)]) {
        // In a real implementation, this would apply labels
        self.set(value);
    }
}

impl MetricExt for Histogram {
    fn record_with_labels(&self, value: f64, labels: &[(&str, &str)]) {
        // In a real implementation, this would apply labels
        self.record(value);
    }
}