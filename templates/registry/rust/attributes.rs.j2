//! Generated attribute constants and metadata for SwarmSH v2 telemetry
//! 
//! This code is generated by OTEL Weaver from semantic conventions.
//! DO NOT EDIT MANUALLY.
//!
//! Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
//! Generation timestamp: {{ params.generation_timestamp | default(now()) }}

use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Attribute metadata
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct AttributeMetadata {
    /// Attribute identifier
    pub id: String,
    /// Brief description
    pub brief: String,
    /// Detailed notes
    pub note: Option<String>,
    /// Attribute type
    pub attr_type: AttributeType,
    /// Examples of valid values
    pub examples: Vec<String>,
    /// Requirement level
    pub requirement_level: RequirementLevel,
    /// Stability status
    pub stability: Stability,
    /// Deprecated message if applicable
    pub deprecated: Option<String>,
    /// Semantic convention group
    pub group: String,
    /// Tags for categorization
    pub tags: Vec<String>,
}

/// Attribute data types
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum AttributeType {
    String,
    Int,
    Double,
    Boolean,
    StringArray,
    IntArray,
    DoubleArray,
    BooleanArray,
}

/// Requirement levels for attributes
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum RequirementLevel {
    Required,
    ConditionallyRequired { condition: String },
    Recommended,
    OptIn,
}

/// Stability status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum Stability {
    Stable,
    Experimental,
    Deprecated,
}

{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
/// {{ group.brief }}
      {% if group.note %}
///
{{ group.note | comment("rust") }}
      {% endif %}
pub mod {{ group.id | replace(".", "_") | snake_case }} {
    use super::*;

      {% for attr in group.attributes %}
    /// {{ attr.brief }}
        {% if attr.note %}
    ///
    {{ attr.note | comment("rust") | indent(4) }}
        {% endif %}
        {% if attr.examples %}
    ///
    /// # Examples
          {% for example in attr.examples %}
    /// - `{{ example }}`
          {% endfor %}
        {% endif %}
        {% if attr.requirement_level == "required" %}
    ///
    /// **Required attribute**
        {% elif attr.requirement_level == "recommended" %}
    ///
    /// **Recommended attribute**
        {% endif %}
        {% if attr.deprecated %}
    ///
    /// **Deprecated**: {{ attr.deprecated }}
        {% endif %}
    pub const {{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | screaming_snake_case }}: &str = "{{ attr.id }}";

      {% endfor %}

    /// Get all attribute constants for this group
    pub fn all_attributes() -> Vec<&'static str> {
        vec![
            {% for attr in group.attributes %}
            {{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | screaming_snake_case }},
            {% endfor %}
        ]
    }

    /// Get required attributes for this group
    pub fn required_attributes() -> Vec<&'static str> {
        vec![
            {% for attr in group.attributes %}
              {% if attr.requirement_level == "required" %}
            {{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | screaming_snake_case }},
              {% endif %}
            {% endfor %}
        ]
    }

    /// Get recommended attributes for this group
    pub fn recommended_attributes() -> Vec<&'static str> {
        vec![
            {% for attr in group.attributes %}
              {% if attr.requirement_level == "recommended" %}
            {{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | screaming_snake_case }},
              {% endif %}
            {% endfor %}
        ]
    }

    /// Get attribute metadata for this group
    pub fn metadata() -> HashMap<&'static str, AttributeMetadata> {
        let mut map = HashMap::new();
        
        {% for attr in group.attributes %}
        map.insert(
            {{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | screaming_snake_case }},
            AttributeMetadata {
                id: "{{ attr.id }}".to_string(),
                brief: "{{ attr.brief }}".to_string(),
                note: {% if attr.note %}Some("{{ attr.note | escape }}".to_string()){% else %}None{% endif %},
                attr_type: AttributeType::{{ attr.type | rust_attr_type }},
                examples: vec![
                    {% for example in attr.examples %}
                    "{{ example }}".to_string(),
                    {% endfor %}
                ],
                requirement_level: {% if attr.requirement_level == "required" %}RequirementLevel::Required{% elif attr.requirement_level == "recommended" %}RequirementLevel::Recommended{% elif attr.requirement_level.condition %}RequirementLevel::ConditionallyRequired { condition: "{{ attr.requirement_level.condition }}".to_string() }{% else %}RequirementLevel::OptIn{% endif %},
                stability: Stability::{% if attr.stability %}{{ attr.stability | capitalize }}{% else %}Stable{% endif %},
                deprecated: {% if attr.deprecated %}Some("{{ attr.deprecated }}".to_string()){% else %}None{% endif %},
                group: "{{ group.id }}".to_string(),
                tags: vec![
                    {% if attr.tags %}
                      {% for tag in attr.tags %}
                    "{{ tag }}".to_string(),
                      {% endfor %}
                    {% endif %}
                ],
            }
        );
        {% endfor %}
        
        map
    }
}

    {% endfor %}
  {% endif %}
{% endfor %}

/// Global attribute registry
lazy_static! {
    pub static ref ATTRIBUTE_REGISTRY: HashMap<String, AttributeMetadata> = {
        let mut registry = HashMap::new();
        
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
        // Add {{ group.id }} attributes
        for (key, metadata) in {{ group.id | replace(".", "_") | snake_case }}::metadata() {
            registry.insert(key.to_string(), metadata);
        }
        
            {% endfor %}
          {% endif %}
        {% endfor %}
        
        registry
    };
}

/// Validate an attribute value against its metadata
pub fn validate_attribute(attr_name: &str, value: &str) -> Result<(), String> {
    if let Some(metadata) = ATTRIBUTE_REGISTRY.get(attr_name) {
        match &metadata.attr_type {
            AttributeType::String => {
                // Check if value matches any examples (if examples are exhaustive)
                if !metadata.examples.is_empty() && metadata.tags.contains(&"enum".to_string()) {
                    if !metadata.examples.contains(&value.to_string()) {
                        return Err(format!(
                            "Invalid value '{}' for attribute '{}'. Valid values: {:?}",
                            value, attr_name, metadata.examples
                        ));
                    }
                }
                Ok(())
            }
            AttributeType::Int => {
                value.parse::<i64>()
                    .map(|_| ())
                    .map_err(|_| format!("Value '{}' is not a valid integer for attribute '{}'", value, attr_name))
            }
            AttributeType::Double => {
                value.parse::<f64>()
                    .map(|_| ())
                    .map_err(|_| format!("Value '{}' is not a valid double for attribute '{}'", value, attr_name))
            }
            AttributeType::Boolean => {
                match value {
                    "true" | "false" => Ok(()),
                    _ => Err(format!("Value '{}' is not a valid boolean for attribute '{}'", value, attr_name))
                }
            }
            _ => Ok(()), // Array types need special handling
        }
    } else {
        // Unknown attribute - allow it but log warning
        tracing::warn!("Unknown attribute: {}", attr_name);
        Ok(())
    }
}

/// Get all known attribute names
pub fn all_known_attributes() -> Vec<String> {
    ATTRIBUTE_REGISTRY.keys().cloned().collect()
}

/// Get attributes by requirement level
pub fn attributes_by_requirement(level: RequirementLevel) -> Vec<String> {
    ATTRIBUTE_REGISTRY
        .iter()
        .filter(|(_, metadata)| metadata.requirement_level == level)
        .map(|(key, _)| key.clone())
        .collect()
}

/// Get attributes by stability
pub fn attributes_by_stability(stability: Stability) -> Vec<String> {
    ATTRIBUTE_REGISTRY
        .iter()
        .filter(|(_, metadata)| metadata.stability == stability)
        .map(|(key, _)| key.clone())
        .collect()
}

/// Get deprecated attributes
pub fn deprecated_attributes() -> Vec<(String, String)> {
    ATTRIBUTE_REGISTRY
        .iter()
        .filter_map(|(key, metadata)| {
            metadata.deprecated.as_ref().map(|msg| (key.clone(), msg.clone()))
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_attribute_constants() {
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% for attr in group.attributes %}
        assert_eq!({{ group.id | replace(".", "_") | snake_case }}::{{ attr.id | replace(group.id ~ ".", "") | replace(".", "_") | screaming_snake_case }}, "{{ attr.id }}");
              {% endfor %}
            {% endfor %}
          {% endif %}
        {% endfor %}
    }

    #[test]
    fn test_required_attributes() {
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
        let required = {{ group.id | replace(".", "_") | snake_case }}::required_attributes();
              {% set req_count = group.attributes | selectattr("requirement_level", "eq", "required") | list | length %}
        assert_eq!(required.len(), {{ req_count }});
            {% endfor %}
          {% endif %}
        {% endfor %}
    }

    #[test]
    fn test_attribute_validation() {
        // Test string validation
        assert!(validate_attribute("swarmsh.agent.status", "active").is_ok());
        
        // Test integer validation
        assert!(validate_attribute("swarmsh.agent.capacity", "100").is_ok());
        assert!(validate_attribute("swarmsh.agent.capacity", "not_a_number").is_err());
    }

    #[test]
    fn test_attribute_registry() {
        assert!(!ATTRIBUTE_REGISTRY.is_empty());
        
        // Check a known attribute
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% if group.attributes %}
        assert!(ATTRIBUTE_REGISTRY.contains_key("{{ group.attributes[0].id }}"));
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
    }
}