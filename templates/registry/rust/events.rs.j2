//! Generated event recording for SwarmSH v2 telemetry
//! 
//! This code is generated by OTEL Weaver from semantic conventions.
//! DO NOT EDIT MANUALLY.
//!
//! Generated from semantic conventions version: {{ params.semconv_version | default("1.0.0") }}
//! Generation timestamp: {{ params.generation_timestamp | default(now()) }}

use opentelemetry::{
    logs::{LogRecord, Severity},
    trace::SpanContext,
    Key, KeyValue, Value,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::SystemTime;
use tracing::{event, Level};

use crate::telemetry::errors::TelemetryError;
use crate::telemetry::validation::validate_attributes;

/// Event severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum EventSeverity {
    Trace,
    Debug,
    Info,
    Warn,
    Error,
    Fatal,
}

impl From<EventSeverity> for Severity {
    fn from(severity: EventSeverity) -> Self {
        match severity {
            EventSeverity::Trace => Severity::Trace,
            EventSeverity::Debug => Severity::Debug,
            EventSeverity::Info => Severity::Info,
            EventSeverity::Warn => Severity::Warn,
            EventSeverity::Error => Severity::Error,
            EventSeverity::Fatal => Severity::Fatal,
        }
    }
}

impl From<EventSeverity> for Level {
    fn from(severity: EventSeverity) -> Self {
        match severity {
            EventSeverity::Trace => Level::TRACE,
            EventSeverity::Debug => Level::DEBUG,
            EventSeverity::Info => Level::INFO,
            EventSeverity::Warn => Level::WARN,
            EventSeverity::Error | EventSeverity::Fatal => Level::ERROR,
        }
    }
}

{% for convention in ctx %}
  {% if convention.groups %}
    {% for group in convention.groups %}
      {% if group.events or group.type == "event" %}
/// {{ group.brief }} events
{% if group.note %}
///
{{ group.note | comment("rust") }}
{% endif %}
pub mod {{ group.id | replace(".", "_") | snake_case }}_events {
    use super::*;

        {% if group.events %}
          {% for event in group.events %}
    /// {{ event.brief }}
            {% if event.note %}
    ///
    {{ event.note | comment("rust") | indent(4) }}
            {% endif %}
    #[derive(Debug, Clone)]
    pub struct {{ event.id | replace(group.id ~ ".", "") | replace(".", "_") | pascal_case }}Event {
        /// Event name
        pub name: String,
        /// Event severity
        pub severity: EventSeverity,
        /// Event message
        pub message: String,
        /// Event attributes
        pub attributes: HashMap<String, KeyValue>,
        /// Timestamp
        pub timestamp: SystemTime,
    }

    impl {{ event.id | replace(group.id ~ ".", "") | replace(".", "_") | pascal_case }}Event {
        /// Create a new {{ event.id }} event
        pub fn new(message: impl Into<String>) -> Self {
            Self {
                name: "{{ event.id }}".to_string(),
                severity: EventSeverity::{{ event.severity | default("Info") | capitalize }},
                message: message.into(),
                attributes: HashMap::new(),
                timestamp: SystemTime::now(),
            }
        }

        /// Set the severity level
        pub fn with_severity(mut self, severity: EventSeverity) -> Self {
            self.severity = severity;
            self
        }

        /// Add an attribute
        pub fn with_attribute(mut self, key: impl Into<String>, value: impl Into<KeyValue>) -> Self {
            self.attributes.insert(key.into(), value.into());
            self
        }

        /// Add multiple attributes
        pub fn with_attributes<I>(mut self, attributes: I) -> Self
        where
            I: IntoIterator<Item = (String, KeyValue)>,
        {
            self.attributes.extend(attributes);
            self
        }

              {% for attr in event.attributes | default([]) %}
        /// Set {{ attr.id }} attribute
                {% if attr.brief %}
        /// {{ attr.brief }}
                {% endif %}
        pub fn with_{{ attr.id | replace(event.id ~ ".", "") | replace(".", "_") }}(mut self, value: {{ attr.type | rust_type }}) -> Self {
            self.with_attribute("{{ attr.id }}", value.into())
        }

              {% endfor %}

        /// Record the event using tracing
        pub fn record_tracing(self) {
            match self.severity {
                EventSeverity::Trace => event!(Level::TRACE, name = %self.name, "{}", self.message),
                EventSeverity::Debug => event!(Level::DEBUG, name = %self.name, "{}", self.message),
                EventSeverity::Info => event!(Level::INFO, name = %self.name, "{}", self.message),
                EventSeverity::Warn => event!(Level::WARN, name = %self.name, "{}", self.message),
                EventSeverity::Error => event!(Level::ERROR, name = %self.name, "{}", self.message),
                EventSeverity::Fatal => event!(Level::ERROR, name = %self.name, fatal = true, "{}", self.message),
            }
        }

        /// Convert to OpenTelemetry LogRecord
        pub fn to_log_record(self) -> LogRecord {
            let mut record = LogRecord::builder()
                .with_severity(self.severity.into())
                .with_body(self.message.clone())
                .with_timestamp(self.timestamp)
                .build();

            // Add event name as attribute
            record.add_attribute(Key::new("event.name"), Value::from(self.name));

            // Add all other attributes
            for (key, value) in self.attributes {
                record.add_attribute(Key::new(key), value);
            }

            record
        }
    }

    /// Helper function to create {{ event.id }} event
    pub fn {{ event.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}(message: impl Into<String>) -> {{ event.id | replace(group.id ~ ".", "") | replace(".", "_") | pascal_case }}Event {
        {{ event.id | replace(group.id ~ ".", "") | replace(".", "_") | pascal_case }}Event::new(message)
    }

          {% endfor %}
        {% endif %}

    /// Record a generic event for this domain
    pub fn record_event(
        name: &str,
        severity: EventSeverity,
        message: impl Into<String>,
        attributes: HashMap<String, KeyValue>,
    ) {
        let level: Level = severity.into();
        event!(
            level,
            domain = "{{ group.id }}",
            event.name = %name,
            ?attributes,
            "{}",
            message.into()
        );
    }
}

      {% endif %}
    {% endfor %}
  {% endif %}
{% endfor %}

/// Generic event builder for domains not covered by semantic conventions
#[derive(Debug, Clone)]
pub struct GenericEvent {
    pub domain: String,
    pub name: String,
    pub severity: EventSeverity,
    pub message: String,
    pub attributes: HashMap<String, KeyValue>,
    pub timestamp: SystemTime,
}

impl GenericEvent {
    /// Create a new generic event
    pub fn new(domain: impl Into<String>, name: impl Into<String>, message: impl Into<String>) -> Self {
        Self {
            domain: domain.into(),
            name: name.into(),
            severity: EventSeverity::Info,
            message: message.into(),
            attributes: HashMap::new(),
            timestamp: SystemTime::now(),
        }
    }

    /// Set the severity level
    pub fn with_severity(mut self, severity: EventSeverity) -> Self {
        self.severity = severity;
        self
    }

    /// Add an attribute
    pub fn with_attribute(mut self, key: impl Into<String>, value: impl Into<KeyValue>) -> Self {
        self.attributes.insert(key.into(), value.into());
        self
    }

    /// Record the event
    pub fn record(self) {
        let level: Level = self.severity.into();
        event!(
            level,
            domain = %self.domain,
            event.name = %self.name,
            ?self.attributes,
            "{}",
            self.message
        );
    }
}

/// Event recording macros
#[macro_export]
macro_rules! record_event {
    ($domain:expr, $name:expr, $message:expr) => {
        $crate::telemetry::events::GenericEvent::new($domain, $name, $message).record()
    };
    ($domain:expr, $name:expr, $severity:expr, $message:expr) => {
        $crate::telemetry::events::GenericEvent::new($domain, $name, $message)
            .with_severity($severity)
            .record()
    };
    ($domain:expr, $name:expr, $severity:expr, $message:expr, $($key:expr => $value:expr),*) => {
        {
            let mut event = $crate::telemetry::events::GenericEvent::new($domain, $name, $message)
                .with_severity($severity);
            $(
                event = event.with_attribute($key, $value);
            )*
            event.record()
        }
    };
}

/// Common event types
pub mod common {
    use super::*;

    /// System startup event
    pub fn system_startup(version: &str) -> GenericEvent {
        GenericEvent::new("system", "startup", "System starting up")
            .with_attribute("version", version)
            .with_severity(EventSeverity::Info)
    }

    /// System shutdown event
    pub fn system_shutdown(reason: &str) -> GenericEvent {
        GenericEvent::new("system", "shutdown", "System shutting down")
            .with_attribute("reason", reason)
            .with_severity(EventSeverity::Info)
    }

    /// Configuration change event
    pub fn config_changed(component: &str, key: &str, old_value: &str, new_value: &str) -> GenericEvent {
        GenericEvent::new("config", "changed", format!("Configuration changed: {}", key))
            .with_attribute("component", component)
            .with_attribute("key", key)
            .with_attribute("old_value", old_value)
            .with_attribute("new_value", new_value)
            .with_severity(EventSeverity::Info)
    }

    /// Error event
    pub fn error_occurred(component: &str, error: &str, details: Option<&str>) -> GenericEvent {
        let mut event = GenericEvent::new("error", "occurred", format!("Error in {}: {}", component, error))
            .with_attribute("component", component)
            .with_attribute("error", error)
            .with_severity(EventSeverity::Error);
        
        if let Some(details) = details {
            event = event.with_attribute("details", details);
        }
        
        event
    }

    /// Performance threshold exceeded
    pub fn performance_threshold_exceeded(
        metric: &str,
        threshold: f64,
        actual: f64,
        component: &str,
    ) -> GenericEvent {
        GenericEvent::new("performance", "threshold_exceeded", 
            format!("Performance threshold exceeded for {}: {} > {}", metric, actual, threshold))
            .with_attribute("metric", metric)
            .with_attribute("threshold", threshold)
            .with_attribute("actual", actual)
            .with_attribute("component", component)
            .with_severity(EventSeverity::Warn)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_event_creation() {
        {% for convention in ctx %}
          {% if convention.groups %}
            {% for group in convention.groups %}
              {% if group.events %}
                {% for event in group.events %}
        let event = {{ group.id | replace(".", "_") | snake_case }}_events::{{ event.id | replace(group.id ~ ".", "") | replace(".", "_") | snake_case }}("Test message");
        assert_eq!(event.name, "{{ event.id }}");
        assert_eq!(event.severity, EventSeverity::{{ event.severity | default("Info") | capitalize }});
                {% endfor %}
              {% endif %}
            {% endfor %}
          {% endif %}
        {% endfor %}
    }

    #[test]
    fn test_generic_event() {
        let event = GenericEvent::new("test", "test_event", "Test message")
            .with_severity(EventSeverity::Debug)
            .with_attribute("key", "value");
        
        assert_eq!(event.domain, "test");
        assert_eq!(event.name, "test_event");
        assert_eq!(event.severity, EventSeverity::Debug);
        assert!(event.attributes.contains_key("key"));
    }

    #[test]
    fn test_common_events() {
        let startup = common::system_startup("1.0.0");
        assert_eq!(startup.name, "startup");
        
        let error = common::error_occurred("test_component", "Test error", Some("Details"));
        assert_eq!(error.severity, EventSeverity::Error);
    }
}