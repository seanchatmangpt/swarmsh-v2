#!/bin/bash
# Generated by SwarmSH v2 Shell Exporter - OTEL Telemetry Module
# Telemetry Collection and Export - $(date)
# Version: 2.0.0

set -euo pipefail

# OTEL-compatible telemetry collection for SwarmSH v2
# Maintains observability-first principles in pure shell

# Configuration
TELEMETRY_DIR="${TELEMETRY_DIR:-/tmp/swarmsh_telemetry}"
TELEMETRY_EXPORT_FORMAT="${TELEMETRY_EXPORT_FORMAT:-json}"
TELEMETRY_BATCH_SIZE="${TELEMETRY_BATCH_SIZE:-100}"
TELEMETRY_FLUSH_INTERVAL="${TELEMETRY_FLUSH_INTERVAL:-5}"

# Ensure telemetry directory exists
mkdir -p "$TELEMETRY_DIR"/{spans,metrics,logs}

# Generate trace ID with nanosecond precision
generate_trace_id() {
    echo "trace_$(date +%s%N)_$(openssl rand -hex 8 2>/dev/null || echo $RANDOM)"
}

# Generate span ID with nanosecond precision
generate_span_id() {
    echo "span_$(date +%s%N)_$(openssl rand -hex 4 2>/dev/null || echo $RANDOM)"
}

# Start a new span
start_span() {
    local span_name="$1"
    local trace_id="${2:-$(generate_trace_id)}"
    local parent_span_id="${3:-}"
    local attributes="${4:-}"
    
    local span_id=$(generate_span_id)
    local start_time=$(date +%s%N)
    
    # Create span file
    local span_file="$TELEMETRY_DIR/spans/${span_id}.json"
    
    cat > "$span_file" <<EOF
{
    "span_id": "$span_id",
    "trace_id": "$trace_id",
    "parent_span_id": "$parent_span_id",
    "name": "$span_name",
    "start_time": $start_time,
    "attributes": ${attributes:-{}},
    "events": [],
    "status": "in_progress"
}
EOF
    
    echo "$span_id"
}

# End a span
end_span() {
    local span_id="$1"
    local status="${2:-ok}"
    local status_message="${3:-}"
    
    local span_file="$TELEMETRY_DIR/spans/${span_id}.json"
    if [[ ! -f "$span_file" ]]; then
        echo "Error: Span $span_id not found" >&2
        return 1
    fi
    
    local end_time=$(date +%s%N)
    
    # Update span with end time and status
    local temp_file="${span_file}.tmp"
    jq --arg end_time "$end_time" \
       --arg status "$status" \
       --arg status_message "$status_message" \
       '.end_time = ($end_time | tonumber) | .status = $status | .status_message = $status_message' \
       "$span_file" > "$temp_file"
    
    mv "$temp_file" "$span_file"
}

# Add event to span
add_span_event() {
    local span_id="$1"
    local event_name="$2"
    local attributes="${3:-{}}"
    
    local span_file="$TELEMETRY_DIR/spans/${span_id}.json"
    if [[ ! -f "$span_file" ]]; then
        echo "Error: Span $span_id not found" >&2
        return 1
    fi
    
    local timestamp=$(date +%s%N)
    local event=$(jq -n \
        --arg name "$event_name" \
        --arg timestamp "$timestamp" \
        --argjson attributes "$attributes" \
        '{name: $name, timestamp: ($timestamp | tonumber), attributes: $attributes}')
    
    local temp_file="${span_file}.tmp"
    jq --argjson event "$event" '.events += [$event]' "$span_file" > "$temp_file"
    mv "$temp_file" "$span_file"
}

# Record metric
record_metric() {
    local metric_name="$1"
    local value="$2"
    local metric_type="${3:-gauge}"
    local labels="${4:-{}}"
    
    local timestamp=$(date +%s%N)
    local metric_file="$TELEMETRY_DIR/metrics/${metric_name}_${timestamp}.json"
    
    cat > "$metric_file" <<EOF
{
    "name": "$metric_name",
    "value": $value,
    "type": "$metric_type",
    "timestamp": $timestamp,
    "labels": $labels
}
EOF
}

# SwarmSH-specific telemetry helpers

# Agent lifecycle span
agent_lifecycle_span() {
    local operation="$1"
    local agent_id="$2"
    local attributes=$(cat <<EOF
{
    "swarmsh.agent.id": "$agent_id",
    "swarmsh.agent.operation": "$operation",
    "swarmsh.agent.lifecycle": true
}
EOF
)
    
    start_span "swarmsh.agent.lifecycle" "" "" "$attributes"
}

# Work coordination span
work_coordination_span() {
    local operation="$1"
    local work_id="$2"
    local agent_id="${3:-}"
    local trace_id="${4:-$(generate_trace_id)}"
    
    local attributes=$(cat <<EOF
{
    "swarmsh.work.id": "$work_id",
    "swarmsh.work.operation": "$operation",
    "swarmsh.work.agent_id": "$agent_id"
}
EOF
)
    
    start_span "swarmsh.work.coordination" "$trace_id" "" "$attributes"
}

# Coordination protocol span
coordination_protocol_span() {
    local pattern="$1"
    local operation="$2"
    local participants="${3:-[]}"
    
    local attributes=$(cat <<EOF
{
    "swarmsh.coordination.pattern": "$pattern",
    "swarmsh.coordination.operation": "$operation",
    "swarmsh.coordination.participants": $participants
}
EOF
)
    
    start_span "swarmsh.coordination.protocol" "" "" "$attributes"
}

# Record SwarmSH metrics
record_agent_metrics() {
    local agent_id="$1"
    local active_work_count="${2:-0}"
    local capacity_used="${3:-0.0}"
    
    record_metric "swarmsh.agent.active_work" "$active_work_count" "gauge" \
        "{\"agent_id\": \"$agent_id\"}"
    
    record_metric "swarmsh.agent.capacity_used" "$capacity_used" "gauge" \
        "{\"agent_id\": \"$agent_id\"}"
    
    record_metric "swarmsh.agent.heartbeat" "1" "counter" \
        "{\"agent_id\": \"$agent_id\"}"
}

record_work_metrics() {
    local pattern="$1"
    local pending_count="${2:-0}"
    local claimed_count="${3:-0}"
    local completed_count="${4:-0}"
    
    record_metric "swarmsh.work.pending" "$pending_count" "gauge" \
        "{\"coordination_pattern\": \"$pattern\"}"
    
    record_metric "swarmsh.work.claimed" "$claimed_count" "gauge" \
        "{\"coordination_pattern\": \"$pattern\"}"
    
    record_metric "swarmsh.work.completed" "$completed_count" "counter" \
        "{\"coordination_pattern\": \"$pattern\"}"
}

# Export telemetry data
export_telemetry() {
    local export_format="${1:-$TELEMETRY_EXPORT_FORMAT}"
    local output_file="${2:-}"
    
    echo "Exporting telemetry in $export_format format..."
    
    case "$export_format" in
        "json")
            export_telemetry_json "$output_file"
            ;;
        "otlp")
            export_telemetry_otlp "$output_file"
            ;;
        "prometheus")
            export_telemetry_prometheus "$output_file"
            ;;
        *)
            echo "Unknown export format: $export_format"
            return 1
            ;;
    esac
}

export_telemetry_json() {
    local output_file="${1:-/tmp/swarmsh_telemetry_export.json}"
    
    local spans=$(find "$TELEMETRY_DIR/spans" -name "*.json" -type f 2>/dev/null | \
        xargs -I {} cat {} | jq -s '.')
    
    local metrics=$(find "$TELEMETRY_DIR/metrics" -name "*.json" -type f 2>/dev/null | \
        xargs -I {} cat {} | jq -s '.')
    
    jq -n \
        --argjson spans "${spans:-[]}" \
        --argjson metrics "${metrics:-[]}" \
        '{spans: $spans, metrics: $metrics, export_time: now}' > "$output_file"
    
    echo "Telemetry exported to: $output_file"
}

export_telemetry_otlp() {
    local output_file="${1:-/tmp/swarmsh_telemetry_export.otlp}"
    echo "OTLP export not yet implemented in shell version"
    # TODO: Implement OTLP format export
}

export_telemetry_prometheus() {
    local output_file="${1:-/tmp/swarmsh_telemetry_export.prom}"
    
    echo "# SwarmSH v2 Telemetry Export - Prometheus Format" > "$output_file"
    echo "# Generated at $(date)" >> "$output_file"
    
    # Export metrics in Prometheus format
    find "$TELEMETRY_DIR/metrics" -name "*.json" -type f 2>/dev/null | while read -r metric_file; do
        local metric=$(cat "$metric_file")
        local name=$(echo "$metric" | jq -r '.name')
        local value=$(echo "$metric" | jq -r '.value')
        local labels=$(echo "$metric" | jq -r '.labels | to_entries | map("\(.key)=\"\(.value)\"") | join(",")')
        
        if [[ -n "$labels" ]]; then
            echo "${name}{${labels}} ${value}" >> "$output_file"
        else
            echo "${name} ${value}" >> "$output_file"
        fi
    done
    
    echo "Prometheus metrics exported to: $output_file"
}

# Telemetry flush daemon
start_telemetry_daemon() {
    local flush_interval="${1:-$TELEMETRY_FLUSH_INTERVAL}"
    
    echo "Starting telemetry flush daemon (interval: ${flush_interval}s)"
    
    while true; do
        sleep "$flush_interval"
        
        # Export and rotate telemetry
        local export_file="/tmp/swarmsh_telemetry_$(date +%s).json"
        export_telemetry_json "$export_file"
        
        # Archive old telemetry
        find "$TELEMETRY_DIR" -name "*.json" -mmin +5 -delete 2>/dev/null || true
        
        echo "Telemetry flushed to: $export_file"
    done &
    
    local daemon_pid=$!
    echo "$daemon_pid" > "$TELEMETRY_DIR/daemon.pid"
    echo "Telemetry daemon started (PID: $daemon_pid)"
}

# Main telemetry interface
main() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        "start_span")
            start_span "$@"
            ;;
        "end_span")
            end_span "$@"
            ;;
        "event")
            add_span_event "$@"
            ;;
        "metric")
            record_metric "$@"
            ;;
        "agent_span")
            agent_lifecycle_span "$@"
            ;;
        "work_span")
            work_coordination_span "$@"
            ;;
        "coord_span")
            coordination_protocol_span "$@"
            ;;
        "export")
            export_telemetry "$@"
            ;;
        "daemon")
            start_telemetry_daemon "$@"
            ;;
        "help")
            echo "SwarmSH v2 Telemetry System - Shell Export"
            echo "Usage: $0 <command> [args...]"
            echo ""
            echo "Commands:"
            echo "  start_span <name> [trace_id] [parent_id] [attrs]  - Start new span"
            echo "  end_span <span_id> [status] [message]              - End span"
            echo "  event <span_id> <name> [attributes]                - Add span event"
            echo "  metric <name> <value> [type] [labels]              - Record metric"
            echo "  agent_span <operation> <agent_id>                  - Agent lifecycle span"
            echo "  work_span <operation> <work_id> [agent_id]         - Work coordination span"
            echo "  coord_span <pattern> <operation> [participants]    - Coordination span"
            echo "  export [format] [output_file]                      - Export telemetry"
            echo "  daemon [interval]                                  - Start flush daemon"
            echo "  help                                               - Show this help"
            echo ""
            echo "Observability-first coordination with OTEL compatibility"
            ;;
        *)
            echo "Unknown command: $command"
            echo "Use '$0 help' for usage information"
            return 1
            ;;
    esac
}

# Execute main function if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi